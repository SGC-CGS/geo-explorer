<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: main.min.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: main.min.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function () {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i &lt; props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" &amp;&amp; superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call &amp;&amp; (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  var _nls = null;
  var _locale = null;
  var _templatables = {};
  var _id = 0;

  var Core = /*#__PURE__*/function () {
    function Core() {
      _classCallCheck(this, Core);
    }

    _createClass(Core, null, [{
      key: "nls",
      get:
      /**
      * Gets the nls ressources
      *
      * Return : Object, an object containing the nls ressources
      */
      function get() {
        return _nls;
      }
      /**
      * Sets the nls ressources
      */
      ,
      set: function set(value) {
        _nls = value;
      }
      /**
      * Gets the locale String
      *
      * Return : String, a String containing the locale
      */

    }, {
      key: "locale",
      get: function get() {
        return _locale;
      }
      /**
      * Sets the locale String
      */
      ,
      set: function set(value) {
        _locale = value;
      }
      /**
      * Get a localized nls string ressource
      *
      * Parameters :
      *	id : String, the id of the nls ressource to retrieve
      *	subs : Array(String), an array of Strings to substitute in the localized nls string ressource
      *	locale : String, the locale for the nls ressource
      * Return : String, the localized nls string ressource
      */

    }, {
      key: "Nls",
      value: function Nls(id, subs, locale) {
        if (!this.nls) throw new Error("Nls content not set.");
        var itm = this.nls[id];
        if (!itm) throw new Error("Nls String '" + id + "' undefined.");
        var txt = itm[locale ? locale : this.locale];
        if (txt === undefined || txt === null) throw new Error("String does not exist for requested language.");
        return this.Format(txt, subs);
      }
      /**
      * A convenience function to get a deffered object for asynchronous processing. 
      * Removes one level of nesting when working with promises
      *
      * Parameters :
      *	none
      * Return : Object, an object with a Resolve and Reject function
      *
      * { 
      *	promise: the promise object associated to the asynchronous process, 
      *	Resolve: a function to resolve the promise, 
      *	Reject: a function to reject the promise 
      * }
      */

    }, {
      key: "Defer",
      value: function Defer() {
        var defer = {};
        defer.promise = new Promise(function (resolve, reject) {
          defer.Resolve = function (result) {
            resolve(result);
          };

          defer.Reject = function (error) {
            reject(error);
          };
        });
        return defer;
      }
      /**
      * Get or set a templated class definition, this is required to nest Templated UI 
      * components within other Templated UI components.
      *
      * Parameters :
      *	id : String, the id of the templated class definition to get or set
      *	definition : Class, when specified, the class definition to set 
      * Return : Class, the class definition created  
      */

    }, {
      key: "Templatable",
      value: function Templatable(id, definition) {
        if (definition) {
          if (_templatables[id]) throw new Error("Templatable ".concat(id, " is defined multiple times."));else _templatables[id] = definition;
        } else if (!_templatables[id]) throw new Error("Templatable ".concat(id, " is not defined."));

        return _templatables[id];
      }
      /**
      * Get an Array of class definitions by matching its
      *
      * Parameters :
      *	id : String, the id of the nls ressource to retrieve
      *	subs : Array(String), an array of Strings to substitute in the localized nls string ressource
      *	locale : String, the locale for the nls ressource
      * Return : String, the localized nls string ressource
      */

    }, {
      key: "Templated",
      value: function Templated(namespace) {
        var templated = [];

        for (var id in _templatables) {
          if (id.match(namespace)) templated.push(_templatables[id]);
        }

        return templated;
      }
      /**
      * Merges an object into another object. 
      *
      * Parameters :
      *	a : Object, the object that will receive the properties 
      *	b : Object, the object to merge into object A
      * Return : the modified Object
      */

    }, {
      key: "Mixin",
      value: function Mixin(a, b) {
        for (var key in b) {
          if (b.hasOwnProperty(key)) a[key] = b[key];
        } // TODO : Why did I use arguments[0] instead of a?


        return arguments[0];
      }
      /**
      * Debounces a function. The function will be executed after a timeout 
      * unless the function is called again in which case, the timeout will
      * reset
      *
      * Parameters :
      *	delegate : Function, the Function to debounce
      *	threshold : Integer, the timeout length, in milliseconds
      * Return : Function, the debounced function
      */

    }, {
      key: "Debounce",
      value: function Debounce(delegate, threshold) {
        var timeout;
        return function debounced() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key &lt; _len; _key++) {
            args[_key] = arguments[_key];
          }

          function delayed() {
            delegate.apply(this, args);
            timeout = null;
          }

          if (timeout) clearTimeout(timeout);
          timeout = setTimeout(delayed.bind(this), threshold || 100);
        };
      }
      /**
      * Formats a String using substitute strings
      *
      * Parameters :
      *	str : String, the String to format
      *	subs : Array(String), An array of Strings to substitute into the String
      * Return : String, the formatted String
      */

    }, {
      key: "Format",
      value: function Format(str, subs) {
        if (!subs || subs.length == 0) return str;
        var s = str;

        for (var i = 0; i &lt; subs.length; i++) {
          var reg = new RegExp("\\{" + i + "\\}", "gm");
          s = s.replace(reg, subs[i]);
        }

        return s;
      }
      /**
      * Disables or enables all focusable elements in an array of nodes
      *
      * Parameters :
      *	nodes : Array of DOM elements, the DOM elements where focusable elements will be disabled or enabled
      *	disabled : Boolean, True to disable, False to enable
      */

    }, {
      key: "DisableFocusable",
      value: function DisableFocusable(nodes, disabled) {
        var focusable = ["button", "fieldset", "input", "optgroup", "option", "select", "textarea"];
        nodes.forEach(function (n) {
          var selection = n.querySelectorAll(focusable);
          if (selection.length == 0) return;

          for (var i = 0; i &lt; selection.length; i++) {
            selection[i].disabled = disabled;
          }
        });
      }
    }, {
      key: "NextId",
      value: function NextId() {
        return "auto_".concat(++_id);
      }
    }, {
      key: "RgbToHex",
      value: function RgbToHex(rgb) {
        return "#" + ((1 &lt;&lt; 24) + (rgb[0] &lt;&lt; 16) + (rgb[1] &lt;&lt; 8) + rgb[2]).toString(16).slice(1);
      }
    }, {
      key: "HexToRgb",
      value: function HexToRgb(hex) {
        var m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return m ? [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16)] : null;
      }
    }, {
      key: "WaitForDocument",
      value: function WaitForDocument() {
        var d = Core.Defer();
        if (document.readyState === "complete") d.Resolve();else window.addEventListener('load', function (ev) {
          return d.Resolve();
        });
        return d.promise;
      }
    }]);

    return Core;
  }();

  var Dom = /*#__PURE__*/function () {
    function Dom() {
      _classCallCheck(this, Dom);
    }

    _createClass(Dom, null, [{
      key: "Node",
      value:
      /**
      * Retrieve an Element using a selector
      *
      * Parameters :
      *	pNode : Element, the parent node where to begin the search
      *	selector : String, a selector statement
      * Return : Element, the Element found, null otherwise
      */
      function Node(pNode, selector) {
        return pNode.querySelectorAll(selector).item(0) || null;
      }
      /**
      * Retrieve elements using a selector
      *
      * Parameters :
      *	pNode : Element, the parent node where to begin the search
      *	selector : String, a selector statement
      * Return : Element, the Element found, null otherwise
      */

    }, {
      key: "Nodes",
      value: function Nodes(pNode, selector) {
        return pNode.querySelectorAll(selector) || null;
      }
      /**
      * Create an Element
      *
      * Parameters :
      *	tagName : String, the type of Element to be created (div, span, label, input, etc.)
      *	options : Object, a dictionary type object containing the options to assign to the created Element
      *	pNode : Element, the parent Element where the created Element will be apended
      * Return : Element, The Element created
      */

    }, {
      key: "Create",
      value: function Create(tagName, options, pNode) {
        var elem = document.createElement(tagName);
        Core.Mixin(elem, options);
        this.Place(elem, pNode);
        return elem;
      }
      /**
      * Create an SVG Element
      *
      * Parameters :
      *	tagName : String, the type of SVG Element to be created (rect, path, etc.)
      *	options : Object, a dictionary type object containing the options to assign to the created SVG Element
      *	pNode : Element, the parent Element where the created SVG Element will be apended
      * Return : Element, The SVG Element created
      */

    }, {
      key: "CreateSVG",
      value: function CreateSVG(tagName, options, pNode) {
        var elem = document.createElementNS("http://www.w3.org/2000/svg", tagName);

        for (var id in options) {
          elem.setAttribute(id, options[id]);
        }

        this.Place(elem, pNode);
        return elem;
      }
      /**
      * Create an Element from a namespace
      *
      * Parameters :
      *	ns : String, the URI namespace containing the Element to create 
      *	tagName : String, the type of Element to be created (rect, path, etc.)
      *	options : Object, a dictionary type object containing the options to assign to the created Element
      *	pNode : Element, the parent Element where the created Element will be apended
      *
      * Valid Namespaces are : 
      *	HTML : http://www.w3.org/1999/xhtml
      *	SVG  : http://www.w3.org/2000/svg
      *	XBL  : http://www.mozilla.org/xbl
      *	XUL  : http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul
      *
      * Return : Element, The SVG Element created
      */

    }, {
      key: "CreateNS",
      value: function CreateNS(ns, tagName, options, pNode) {
        var elem = document.createElementNS(ns, tagName);

        for (var id in options) {
          elem.setAttribute(id, options[id]);
        }

        this.Place(elem, pNode);
        return elem;
      }
      /**
      * Append an Element to another Element
      *
      * Parameters :
      *	elem : Element, the Element to append
      *	pNode : Element, the parent Element where the Element will be apended
      * Return : none
      */

    }, {
      key: "Place",
      value: function Place(elem, pNode) {
        if (!!pNode) pNode.appendChild(elem);
      }
      /**
      * Replace an Element by another Element
      *
      * Parameters :
      *	elem1 : Element, the Element to be replaced
      *	elem2 : Element, the Element that will replace elem1
      * Return : none
      */

    }, {
      key: "Replace",
      value: function Replace(elem1, elem2) {
        var pNode = elem1.parentNode;
        pNode.insertBefore(elem2, elem1);
        this.Remove(elem1, pNode);
      }
      /**
      * Remove an Element from another Element
      *
      * Parameters :
      *	elem : Element, the Element to remove
      *	pNode : Element, the parent Element containing the Element to remove
      * Return : none
      */

    }, {
      key: "Remove",
      value: function Remove(elem, pNode) {
        if (!pNode.children.some(function (child) {
          return child === elem;
        })) return;
        pNode.removeChild(elem);
      }
      /**
      * Remove all children of an Element
      *
      * Parameters :
      *	elem : Element, the Element to empty
      * Return : none
      */

    }, {
      key: "Empty",
      value: function Empty(elem) {
        while (elem.firstChild) {
          elem.removeChild(elem.firstChild);
        }
      }
      /**
      * Add a CSS rule on an Element
      *
      * Parameters :
      *	elem : Element, the Element to modify
      *	css : String, the CSS rule to add on the Element
      * Return : none
      */

    }, {
      key: "AddCss",
      value: function AddCss(elem, css) {
        var c1 = elem.className.split(" ");
        css.split(" ").forEach(function (c) {
          if (c1.indexOf(c) == -1) c1.push(c);
        });
        elem.className = c1.join(" ");
      }
      /**
      * Remove a CSS rule on an Element
      *
      * Parameters :
      *	elem : Element, the Element to modify
      *	css : String, the CSS rule to remove from the Element
      * Return : none
      */

    }, {
      key: "RemoveCss",
      value: function RemoveCss(elem, css) {
        var c1 = elem.className.split(" ");
        var c2 = css.split(" ");
        elem.className = c1.filter(function (c) {
          return c2.indexOf(c) == -1;
        }).join(" ");
      }
      /**
      * Verify that an Element contains a CSS rule
      *
      * Parameters :
      *	elem : Element, the Element to verify
      *	css : String, the CSS rule to find
      * Return : Boolean, true if the Element contains the CSS rule, false otherwise
      */

    }, {
      key: "HasCss",
      value: function HasCss(elem, css) {
        return (' ' + elem.className + ' ').indexOf(' ' + css + ' ') > -1;
      }
      /**
      * Set the CSS rules on an Element
      *
      * Parameters :
      *	elem : Element, the Element to modify
      *	css : String, the CSS rule to set on the Element
      * Return : none
      */

    }, {
      key: "SetCss",
      value: function SetCss(elem, css) {
        elem.className = css;
      }
      /**
      * Toggle a CSS rule on or or off for an Element
      *
      * Parameters :
      *	elem : Element, the Element to modify
      *	css : String, the CSS rule to toggle on the Element
      *	enabled : Boolean, true to toggle the CSS rule on, false to toggle it off
      * Return : none
      */

    }, {
      key: "ToggleCss",
      value: function ToggleCss(elem, css, enabled) {
        if (enabled) this.AddCss(elem, css);else this.RemoveCss(elem, css);
      }
      /**
      * Get an attribute value from an Element
      *
      * Parameters :
      *	elem : Element, the Element to retrieve the attribute from
      *	attr : String, the name of the attribute to retrieve
      * Return : String, the value of the attribute if found, null otherwise
      */

    }, {
      key: "GetAttribute",
      value: function GetAttribute(elem, attr) {
        var attr = elem.attributes.getNamedItem(attr);
        return attr ? attr.value : null;
      }
      /**
      * Set an attribute value on an Element
      *
      * Parameters :
      *	elem : Element, the Element to set the attribute on
      *	attr : String, the name of the attribute to set
      *	value : String, the value of the attribute to set
      * Return : none
      */

    }, {
      key: "SetAttribute",
      value: function SetAttribute(elem, attr, value) {
        elem.setAttribute(attr, value);
      }
      /**
      * Get the size of an Element
      *
      * Parameters :
      *	elem : Element, the Element to retrieve the size
      * Return : Object, an object literal containing the size of the Element
      * 
      * { 
      *	w: width of the Element, 
      *	h: height of the Element 
      * }
      */

    }, {
      key: "Size",
      value: function Size(elem) {
        var style = window.getComputedStyle(elem);
        var h = +style.getPropertyValue("height").slice(0, -2);
        var w = +style.getPropertyValue("width").slice(0, -2);
        var pL = +style.getPropertyValue("padding-left").slice(0, -2);
        var pR = +style.getPropertyValue("padding-right").slice(0, -2);
        var pT = +style.getPropertyValue("padding-top").slice(0, -2);
        var pB = +style.getPropertyValue("padding-bottom").slice(0, -2);
        var w = w - pL - pR;
        var h = h - pT - pB; // Use smallest width as width and height for square grid that fits in container
        // var s = w &lt; h ? w : h;

        return {
          w: w,
          h: h
        };
      }
      /**
      * Get the siblings of an Element
      *
      * Parameters :
      *	elem : Element, the Element to retrieve the siblings
      * Return : Array, An array of elements containing the siblings of the input element
      */

    }, {
      key: "Siblings",
      value: function Siblings(elem) {
        var elements = [];

        for (var i = 0; i &lt; elem.parentNode.children.length; i++) {
          elements.push(elem.parentNode.children[i]);
        }

        elements.splice(elements.indexOf(elem), 1);
        return elements;
      }
      /**
      * Returns the geometry of a dom node (width, height)
      *
      * Parameters :
      *	elem : Element, the Element to retrieve the geometry
      * Return : Object, an object containing the width and height of the element
      */

    }, {
      key: "Geometry",
      value: function Geometry(elem) {
        var style = window.getComputedStyle(elem);
        var h = +style.getPropertyValue("height").slice(0, -2);
        var w = +style.getPropertyValue("width").slice(0, -2);
        var pL = +style.getPropertyValue("padding-left").slice(0, -2);
        var pR = +style.getPropertyValue("padding-right").slice(0, -2);
        var pT = +style.getPropertyValue("padding-top").slice(0, -2);
        var pB = +style.getPropertyValue("padding-bottom").slice(0, -2);
        var w = w - pL - pR;
        var h = h - pT - pB; // Use smallest width as width and height for square grid that fits in container
        // var s = w &lt; h ? w : h;

        return {
          w: w,
          h: h
        };
      }
    }]);

    return Dom;
  }();

  var Net = /*#__PURE__*/function () {
    function Net() {
      _classCallCheck(this, Net);
    }

    _createClass(Net, null, [{
      key: "Get",
      value:
      /**
      * Execute a web request
      *
      * Parameters :
      *	url : String, the request URL
      * Return : none
      *
      * TODO : This should return a promise object but (ie11)
      *
      */
      function Get(url, headers, responseType) {
        var d = Core.Defer();
        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {
          if (this.readyState != 4) return;
          if (this.status == 200) d.Resolve(this.response);else d.Reject({
            status: this.status,
            response: this.response
          });
        };

        xhttp.open("GET", url, true);

        if (headers) {
          for (var id in headers) {
            xhttp.setRequestHeader(id, headers[id]);
          }
        }

        if (responseType) xhttp.responseType = responseType;
        xhttp.send();
        return d.promise;
      }
    }, {
      key: "Post",
      value: function Post(url, data, headers, responseType) {
        var d = Core.Defer();
        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {
          if (this.readyState != 4) return;
          if (this.status == 200) d.Resolve(this.response);else d.Reject({
            status: this.status,
            response: this.response
          });
        };

        xhttp.open("POST", url, true);
        if (responseType) xhttp.responseType = responseType;

        if (headers) {
          for (var id in headers) {
            xhttp.setRequestHeader(id, headers[id]);
          }
        }

        data ? xhttp.send(data) : xhttp.send();
        return d.promise;
      }
    }, {
      key: "JSON",
      value: function (_JSON) {
        function JSON(_x) {
          return _JSON.apply(this, arguments);
        }

        JSON.toString = function () {
          return _JSON.toString();
        };

        return JSON;
      }(function (url) {
        var d = Core.Defer();
        Net.Get(url).then(function (r) {
          return d.Resolve(JSON.parse(r));
        }, d.Reject);
        return d.promise;
      })
    }, {
      key: "File",
      value: function (_File) {
        function File(_x2, _x3) {
          return _File.apply(this, arguments);
        }

        File.toString = function () {
          return _File.toString();
        };

        return File;
      }(function (url, name) {
        var d = Core.Defer();
        Net.Get(url, null, 'blob').then(function (b) {
          d.Resolve(new File([b], name));
        }, d.Reject);
        return d.promise;
      }
      /**
      * Get a parameter value from the document URL
      *
      * Parameters :
      *	name : String, the name of the parameter to retrieve from the URL
      * Return : String, the value of the parameter from the URL, an empty string if not found
      */
      )
    }, {
      key: "GetUrlParameter",
      value: function GetUrlParameter(name) {
        name = name.replace(/[\[\]]/g, '\\$&amp;');
        var regex = new RegExp('[?&amp;]' + name + '(=([^&amp;#]*)|&amp;|#|$)');
        var results = regex.exec(window.location.href);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
      }
      /**
      * Download content as a file
      *
      * Parameters :
      *	name : String, the name of the file to download
      *	content : 
      * Return : none
      */

    }, {
      key: "Download",
      value: function Download(name, content) {
        var link = document.createElement("a");
        link.href = "data:application/octet-stream," + encodeURIComponent(content);
        link.download = name;
        link.click();
        link = null;
      }
      /**
      * Gets the base URL for the app
      *
      * Parameters : none
      * Return : String, the base path to the web app
      */

    }, {
      key: "AppPath",
      value: function AppPath() {
        var path = location.href.split("/");
        path.pop();
        return path.join("/");
      }
      /**
      * Gets the base URL for the app
      *
      * Parameters : none
      * Return : String, the base path to the web app
      */

    }, {
      key: "FilePath",
      value: function FilePath(file) {
        file = file.charAt(0) == "/" ? file.substr(1) : file;
        var path = [Net.AppPath(), file];
        return path.join("/");
      }
    }]);

    return Net;
  }();

  var Configuration = /*#__PURE__*/function () {
    function Configuration(json) {
      _classCallCheck(this, Configuration);

      this.json = json;
    }

    _createClass(Configuration, [{
      key: "Map",
      get: function get() {
        return this.json.map;
      }
    }, {
      key: "MapUrl",
      get: function get() {
        return this.json.map.url;
      }
    }, {
      key: "MapOpacity",
      get: function get() {
        return this.json.map.opacity;
      }
    }, {
      key: "Symbol",
      value: function Symbol(id) {
        var s = this.json.symbols[id];
        if (!s) throw new Error("Symbol ".concat(0, " does not exist is the configuration file."));
        return s;
      }
    }, {
      key: "Context",
      get: function get() {
        return this.json.context;
      }
    }, {
      key: "ContextSubject",
      get: function get() {
        return this.json.context.subject;
      }
    }, {
      key: "ContextTheme",
      get: function get() {
        return this.json.context.theme;
      }
    }, {
      key: "ContextCategory",
      get: function get() {
        return this.json.context.category;
      }
    }, {
      key: "ContextFilters",
      get: function get() {
        return this.json.context.filters;
      }
    }, {
      key: "ContextValue",
      get: function get() {
        return this.json.context.value;
      }
    }, {
      key: "ContextGeography",
      get: function get() {
        return this.json.context.geography;
      }
    }, {
      key: "Table",
      get: function get() {
        return this.json.table;
      }
    }, {
      key: "TableHeaders",
      get: function get() {
        return this.json.table.headers.map(function (h) {
          return {
            id: h.id[Core.locale],
            label: h.label[Core.locale]
          };
        });
      }
    }, {
      key: "LegendItems",
      get: function get() {
        return this.json.legend.items.map(function (i) {
          return {
            id: i.id,
            label: i.label[Core.locale],
            url: i.url
          };
        });
      }
    }, {
      key: "Bookmarks",
      get: function get() {
        var bookmarks = this.json.bookmarks.sort(function (a, b) {
          if (a.name > b.name) return 1;
          if (a.name &lt; b.name) return -1;
          return 0;
        });
        return bookmarks.map(function (b) {
          return {
            name: b.name,
            extent: {
              xmin: b.extent[0][0],
              xmax: b.extent[1][0],
              ymin: b.extent[0][1],
              ymax: b.extent[1][1]
            }
          };
        });
      }
    }]);

    return Configuration;
  }();

  var Evented = /*#__PURE__*/function () {
    function Evented() {
      _classCallCheck(this, Evented);

      this.listeners = {};
    }

    _createClass(Evented, [{
      key: "addEventListener",
      value: function addEventListener(type, callback, once) {
        if (!(type in this.listeners)) this.listeners[type] = [];
        var h = {
          target: this,
          type: type,
          callback: callback,
          once: !!once
        };
        this.listeners[type].push(h);
        return h;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, callback) {
        if (!(type in this.listeners)) return;
        var stack = this.listeners[type];

        for (var i = 0, l = stack.length; i &lt; l; i++) {
          if (stack[i].callback === callback) {
            stack.splice(i, 1);
            return this.removeEventListener(type, callback);
          }
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (!(event.type in this.listeners)) return;
        var stack = this.listeners[event.type];

        for (var i = 0; i &lt; stack.length; i++) {
          stack[i].callback.call(this, event);
        }

        for (var i = stack.length - 1; i >= 0; i--) {
          if (!!stack[i].once) this.removeEventListener(event.type, stack[i].callback);
        }
      }
    }, {
      key: "Emit",
      value: function Emit(type, data) {
        // Let base event properties be overwritten by whatever was provided.	
        var event = {
          bubbles: true,
          cancelable: true
        };
        Core.Mixin(event, data); // Use the type that was specifically provided, target is always this.

        event.type = type;
        event.target = this;
        this.dispatchEvent(event);
      }
    }, {
      key: "On",
      value: function On(type, callback) {
        return this.addEventListener(type, callback, false);
      }
    }, {
      key: "Once",
      value: function Once(type, callback) {
        return this.addEventListener(type, callback, true);
      }
    }, {
      key: "Off",
      value: function Off(type, callback) {
        this.removeEventListener(type, callback);
      }
    }]);

    return Evented;
  }();

  var _Node = /*#__PURE__*/function () {
    function _Node(elem) {
      _classCallCheck(this, _Node);

      this.elem = elem;
    }

    _createClass(_Node, [{
      key: "Element",
      get: function get() {
        return this.elem;
      }
    }, {
      key: "On",
      value: function On(type, handler) {
        this.elem.addEventListener(type, handler);
      }
    }, {
      key: "Elem",
      value: function Elem(selector) {
        var elem = this.elem.querySelector(selector);
        return !elem ? null : elem;
      }
    }, {
      key: "Elems",
      value: function Elems(selector) {
        var elems = this.elem.querySelectorAll(selector);
        var out = [];
        elems.forEach(function (e) {
          return out.push(e);
        });
        return out;
      }
    }, {
      key: "Node",
      value: function (_Node2) {
        function Node(_x) {
          return _Node2.apply(this, arguments);
        }

        Node.toString = function () {
          return _Node2.toString();
        };

        return Node;
      }(function (selector) {
        var elem = this.elem.querySelector(selector);
        return !elem ? null : new Node(elem);
      })
    }, {
      key: "Nodes",
      value: function Nodes(selector) {
        var elems = this.elem.querySelectorAll(selector);
        var out = [];
        elems.forEach(function (e) {
          return out.push(new Node(e));
        });
        return out;
      }
    }]);

    return _Node;
  }();

  var Templated = /*#__PURE__*/function (_Evented) {
    _inherits(Templated, _Evented);

    var _super = _createSuper(Templated);

    function Templated(container, options) {
      var _this;

      _classCallCheck(this, Templated);

      _this = _super.call(this);
      _this.options = options || {};

      _this.BuildTemplate();

      if (_this.template) _this.SetNamedNodes();
      if (_this.template) _this.BuildSubWidgets();

      _this.SetRoots();

      if (container) _this.Place(container);
      return _this;
    }

    _createClass(Templated, [{
      key: "BuildTemplate",
      value: function BuildTemplate() {
        // Use template provided in options first, use Template function second
        var html = this.options.template ? this.options.template : this.Template(); // TODO : I think it still works with empty templates.

        if (!html) return; // Trailing whitespaces can cause issues when parsing the template, remove them

        html = html.trim(); // Replace all nls strings in template. Nls string pattern in templates is nls(StringId)

        html = this.Replace(html, /nls\((.*?)\)/, function (m) {
          return Core.Nls(m);
        });
        this.template = Dom.Create("div", {
          innerHTML: html
        });
      }
    }, {
      key: "SetRoots",
      value: function SetRoots() {
        this.roots = [];

        for (var i = 0; i &lt; this.template.children.length; i++) {
          this.roots.push(this.template.children[i]);
        }
      }
    }, {
      key: "SetNamedNodes",
      value: function SetNamedNodes() {
        var named = this.template.querySelectorAll("[handle]");
        this.nodes = {}; // Can't use Array ForEach here since named is a NodeList, not an array

        for (var i = 0; i &lt; named.length; i++) {
          var name = Dom.GetAttribute(named[i], "handle");
          this.nodes[name] = named[i];
        }
      }
    }, {
      key: "BuildSubWidgets",
      value: function BuildSubWidgets() {
        var nodes = this.template.querySelectorAll("[widget]"); // Can't use Array ForEach here since nodes is a NodeList, not an array

        for (var i = 0; i &lt; nodes.length; i++) {
          var path = Dom.GetAttribute(nodes[i], "widget");
          var module = Core.Templatable(path);
          var widget = new module(nodes[i]);
          var handle = Dom.GetAttribute(widget.container, "handle");
          if (handle) this.nodes[handle] = widget;
        }
      }
    }, {
      key: "Place",
      value: function Place(container) {
        var _this2 = this;

        this.container = container;
        this.roots.forEach(function (r) {
          Dom.Place(r, _this2.container);
        });
      }
    }, {
      key: "SetCss",
      value: function SetCss(css) {
        this.roots.forEach(function (r) {
          Dom.SetCss(r, css);
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return null;
      }
    }, {
      key: "Replace",
      value: function Replace(str, expr, delegate) {
        var m = str.match(expr);

        while (m) {
          str = str.replace(m[0], delegate(m[1]));
          m = str.match(expr);
        }

        return str;
      }
    }, {
      key: "Node",
      value: function Node(id) {
        return new _Node(this.nodes[id]);
      }
    }, {
      key: "Elem",
      value: function Elem(id) {
        return this.nodes[id];
      } // NOTE : Test for spread operator in Rollup

    }, {
      key: "Nodes",
      value: function Nodes() {
        var _this3 = this;

        for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key &lt; _len; _key++) {
          ids[_key] = arguments[_key];
        }

        return ids.map(function (id) {
          return new _Node(_this3.nodes[id]);
        });
      } // NOTE : Test for spread operator in Rollup

    }, {
      key: "Elems",
      value: function Elems() {
        var _this4 = this;

        for (var _len2 = arguments.length, ids = new Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) {
          ids[_key2] = arguments[_key2];
        }

        return ids.map(function (id) {
          return _this4.nodes[id];
        });
      } // TODO : Build a root function

    }]);

    return Templated;
  }(Evented);

  var _config = null;
  var URLS = {
    renderer: "https://www97.statcan.gc.ca/arcgis/rest/services/CHSP/stcdv_dyn/MapServer/dynamicLayer/generateRenderer",
    placename: "https://www97.statcan.gc.ca/arcgis/rest/services/CHSP/stcdv_lookup/MapServer/0",
    value: "https://www97.statcan.gc.ca/arcgis/rest/services/CHSP/stcdv_lookup/MapServer/1",
    geography: "https://www97.statcan.gc.ca/arcgis/rest/services/CHSP/stcdv_lookup/MapServer/2",
    indicator: "https://www97.statcan.gc.ca/arcgis/rest/services/CHSP/stcdv_lookup/MapServer/3",
    breaks: "https://www97.statcan.gc.ca/arcgis/rest/services/CHSP/stcdv_lookup/MapServer/4",
    filter: "https://www97.statcan.gc.ca/arcgis/rest/services/CHSP/stcdv_lookup/MapServer/8"
  };

  var Requests = /*#__PURE__*/function () {
    function Requests() {
      _classCallCheck(this, Requests);
    }

    _createClass(Requests, null, [{
      key: "config",
      get: function get() {
        return _config;
      },
      set: function set(value) {
        _config = value;
      }
    }, {
      key: "MakeItem",
      value: function MakeItem(f, value, label, description, locale) {
        var item = {
          value: f.attributes[value],
          label: f.attributes["".concat(label, "_").concat(locale)]
        };
        if (description) item.description = f.attributes["".concat(description, "_").concat(locale)];
        return item;
      }
    }, {
      key: "MakeItems",
      value: function MakeItems(features, value, label, description) {
        var locale = Core.locale.toUpperCase();
        return features.map(function (f) {
          return Requests.MakeItem(f, value, label, description, locale);
        });
      }
    }, {
      key: "MakeMetadata",
      value: function MakeMetadata(attr) {
        return {
          indicator: attr.IndicatorId,
          query: attr.PrimaryQuery,
          breaks: {
            n: attr.DefaultBreaks,
            algoId: attr.DefaultBreaksAlgorithmId,
            algo: null
          },
          colors: {
            start: attr.ColorFrom.split(","),
            end: attr.ColorTo.split(",")
          }
        };
      }
    }, {
      key: "Query",
      value: function Query(layer, where, geometry, returnGeometry, outFields, distinct, orderBy) {
        var query = layer.createQuery();
        query.returnGeometry = !!returnGeometry;
        query.returnDistinctValues = !!distinct;
        if (outFields) query.outFields = outFields;
        if (where) query.where = where;
        if (geometry) query.geometry = geometry;
        if (orderBy) query.orderByFields = orderBy;
        return layer.queryFeatures(query);
      }
    }, {
      key: "QueryGeometry",
      value: function QueryGeometry(layer, geometry) {
        return Requests.Query(layer, null, geometry, true, "*", null, null);
      }
    }, {
      key: "QueryUrl",
      value: function QueryUrl(url, where, geometry, returnGeometry, outFields, distinct, orderBy) {
        var layer = ESRI.layers.FeatureLayer({
          url: url
        });
        return Requests.Query(layer, where, geometry, returnGeometry, outFields, distinct, orderBy);
      }
    }, {
      key: "QueryTable",
      value: function QueryTable(url, where, returnGeometry) {
        return Requests.QueryUrl(url, where, null, !!returnGeometry, "*", true, null);
      }
    }, {
      key: "Indicator",
      value: function Indicator(id) {
        var d = Core.Defer();
        var where = id == null ? "ParentThemeId is ".concat(id) : "ParentThemeId = ".concat(id);
        Requests.QueryTable(URLS.indicator, where).then(function (r) {
          var items = Requests.MakeItems(r.features, "IndicatorThemeId", "IndicatorTheme", "IndicatorThemeDescription");
          items = items.filter(function (i) {
            return i.value % 10000 != 9999;
          });
          d.Resolve(items);
        }, function (error) {
          d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "Category",
      value: function Category(id) {
        var d = Core.Defer();
        var where = "IndicatorThemeId = ".concat(id);
        Requests.QueryTable(URLS.filter, where).then(function (r) {
          var locale = Core.locale.toUpperCase();
          var dimensions = [];
          r.features.forEach(function (f) {
            var i = f.attributes["DisplayOrder"] - 1;

            if (!dimensions[i]) {
              dimensions[i] = {
                id: f.attributes["DimensionId"],
                type: f.attributes["DimensionType"],
                label: f.attributes["Dimension_".concat(locale)],
                values: []
              };
            }

            var item = Requests.MakeItem(f, "DimensionValueId", "Display", null, locale);
            dimensions[i].values.push(item);
          });
          var filters = dimensions.filter(function (d) {
            return d.type == 'Filter';
          });
          var values = dimensions.filter(function (d) {
            return d.type == 'Value';
          });
          if (values.length > 1) d.Reject(new Error("More than one dimension of type Value received."));else d.Resolve({
            filters: filters,
            value: values[0].values
          });
        }, function (error) {
          d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "Metadata",
      value: function Metadata(indicators) {
        var _this = this;

        var d = Core.Defer();
        var where = "DimensionUniqueKey = '".concat(indicators.join("-"), "'");
        Requests.QueryTable(URLS.value, where).then(function (r) {
          if (r.features.length > 1) d.Reject(new Error("Received more than one indicator Id."));

          var metadata = _this.MakeMetadata(r.features[0].attributes);

          Requests.Break(metadata.breaks.algoId).then(function (breaks) {
            metadata.breaks.algo = breaks.BreakAlgorithm;
            d.Resolve(metadata);
          }, function (error) {
            d.Reject(error);
          });
        }, function (error) {
          d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "Geography",
      value: function Geography(indicatorId) {
        var d = Core.Defer();
        var where = "IndicatorId = '".concat(indicatorId, "'");
        Requests.QueryTable(URLS.geography, where).then(function (r) {
          var items = Requests.MakeItems(r.features, "GeographicLevelId", "LevelName", "LevelDescription");
          items = items.filter(function (item) {
            return item.value != "SSSS";
          });
          d.Resolve(items);
        }, function (error) {
          d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "Break",
      value: function Break(id) {
        var d = Core.Defer();
        var where = "BreakAlgorithmId  = ".concat(id);
        Requests.QueryTable(URLS.breaks, where).then(function (r) {
          if (r.features.length > 1) d.Reject(new Error("Received more than one break algorithm."));
          var data = r.features[0].attributes;
          d.Resolve(data);
        }, function (error) {
          d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "Renderer",
      value: function Renderer(context) {
        var meta = context.metadata;
        var d = Core.Defer();
        var layer = {
          "id": 7,
          "minScale": null,
          "name": "dyn_layer",
          "source": {
            "dataSource": {
              "type": "queryTable",
              "workspaceId": "stcdv_dyn_service",
              "query": meta.query,
              "oidFields": "GeographyReferenceId",
              "geometryType": "esriGeometryPolygon"
            },
            "type": "dataLayer"
          },
          "definitionExpression": "GeographicLevelId = '".concat(context.geography, "' AND IndicatorId = ").concat(meta.indicator)
        };
        var classif = {
          "type": "classBreaksDef",
          "classificationField": "Value",
          "classificationMethod": meta.breaks.algo,
          "breakCount": meta.breaks.n,
          "colorRamp": {
            "type": "algorithmic",
            "fromColor": meta.colors.start,
            "toColor": meta.colors.end,
            "algorithm": "esriHSVAlgorithm"
          }
        };
        var data = {
          f: "json",
          layer: JSON.stringify(layer),
          where: "GeographicLevelId = '".concat(context.geography, "' AND IndicatorId = ").concat(meta.indicator),
          classificationDef: JSON.stringify(classif)
        };
        var p = ESRI.request(URLS.renderer, {
          useProxy: true,
          method: "POST",
          responseType: "json",
          query: data
        });
        p.then(function (renderer) {
          var _ref;

          var sublayer = new ESRI.layers.support.Sublayer({
            id: 7,
            visible: true,
            labelsVisible: true,
            definitionExpression: data.where,
            renderer: ESRI.renderers.support.jsonUtils.fromJSON(renderer.data),
            source: {
              type: "data-layer",
              dataSource: {
                type: "query-table",
                workspaceId: "stcdv_dyn_service",
                query: meta.query,
                geometryType: "esriGeometryPolygon",
                oidFields: "GeographyReferenceId"
              }
            },
            labelingInfo: [(_ref = {
              labelExpression: "[DisplayNameShort_EN]",
              labelPlacement: "always-horizontal",
              useCodedValues: false,
              maxScale: 0,
              minScale: 0,
              where: null,
              symbol: {
                type: "text",
                // autocasts as new TextSymbol()
                color: [255, 255, 255, 255],
                haloColor: [0, 0, 0, 255],
                haloSize: 2,
                verticalAlignment: "bottom",
                horizontalAlignment: "left",
                rightToLeft: false,
                angle: 0,
                xoffset: 0,
                yoffset: 0,
                rotated: false,
                kerning: true,
                font: {
                  size: 9,
                  style: "normal",
                  decoration: "none",
                  weight: "normal",
                  family: "Arial"
                }
              }
            }, _defineProperty(_ref, "minScale", 0), _defineProperty(_ref, "maxScale", 0), _ref)]
          });
          d.Resolve(sublayer);
        }, function (error) {
          d.Reject(new Error(error.message));
        });
        return d.promise;
      }
    }, {
      key: "Identify",
      value: function Identify(layer, geometry) {
        var d = Core.Defer();
        Requests.QueryGeometry(layer, geometry).then(function (r) {
          var locale = Core.locale.toUpperCase();
          var f = r.features[0];
          var title = f.attributes["DisplayNameShort_".concat(locale)];
          var unit = f.attributes["UOM_".concat(locale)];
          var value = f.attributes["FormattedValue_".concat(locale)];
          var html = f.attributes["IndicatorDisplay_".concat(locale)];
          var content = "&lt;b>".concat(unit, "&lt;/b>: ").concat(value, "&lt;br>&lt;br>").concat(html);
          d.Resolve({
            feature: f,
            geometry: geometry,
            content: content,
            title: title
          });
        }, function (error) {
          return d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "Typeahead",
      value: function Typeahead(value) {
        var d = Core.Defer();
        var fields = ["GeographyReferenceId", "SearchDisplayName"];
        var where = "UPPER(SearchDisplayName) LIKE UPPER('".concat(value, "%') AND Lang = '").concat(Core.locale.toUpperCase(), "'");
        Requests.QueryUrl(URLS.placename, where, null, false, fields, false, ["SearchDisplayName DESC"]).then(function (r) {
          var items = r.features.map(function (f) {
            return {
              id: f.attributes[fields[0]],
              label: f.attributes[fields[1]],
              feature: f
            };
          });
          d.Resolve(items);
        }, function (error) {
          d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "Placename",
      value: function Placename(id, label) {
        var d = Core.Defer();
        var where = "GeographyReferenceId = '".concat(id, "' and SearchDisplayName = '").concat(label, "'");
        Requests.QueryUrl(URLS.placename, where, null, true).then(function (r) {
          d.Resolve(r.features[0]);
        }, function (error) {
          d.Reject(error);
        });
        return d.promise;
      }
    }]);

    return Requests;
  }();

  var Context = /*#__PURE__*/function (_Evented) {
    _inherits(Context, _Evented);

    var _super = _createSuper(Context);

    function Context() {
      var _this;

      _classCallCheck(this, Context);

      _this = _super.call(this);
      _this.lookups = {
        current: {},
        previous: {}
      };
      _this.selection = {
        current: {},
        previous: {}
      };
      _this._metadata = {
        current: null,
        previous: null
      };
      _this._sublayer = {
        current: null,
        previous: null
      };
      return _this;
    }

    _createClass(Context, [{
      key: "subject",
      get: function get() {
        return this.selection.current.subject;
      },
      set: function set(value) {
        this.selection.current.subject = value;
      }
    }, {
      key: "theme",
      get: function get() {
        return this.selection.current.theme;
      },
      set: function set(value) {
        this.selection.current.theme = value;
      }
    }, {
      key: "category",
      get: function get() {
        return this.selection.current.category;
      },
      set: function set(value) {
        this.selection.current.category = value;
      }
    }, {
      key: "filters",
      get: function get() {
        return this.selection.current.filters;
      },
      set: function set(value) {
        this.selection.current.filters = value;
      }
    }, {
      key: "value",
      get: function get() {
        return this.selection.current.value;
      },
      set: function set(value) {
        this.selection.current.value = value;
      }
    }, {
      key: "geography",
      get: function get() {
        return this.selection.current.geography;
      },
      set: function set(value) {
        this.selection.current.geography = value;
      }
    }, {
      key: "metadata",
      get: function get() {
        return this._metadata.current;
      },
      set: function set(value) {
        this._metadata.current = value;
      }
    }, {
      key: "sublayer",
      get: function get() {
        return this._sublayer.current;
      },
      set: function set(value) {
        this._sublayer.current = value;
      }
    }, {
      key: "indicators",
      get: function get() {
        return this.filters.concat([this.value]);
      }
    }, {
      key: "Initialize",
      value: function Initialize(config) {
        var _this2 = this;

        this.Emit("Busy");
        var d = Core.Defer();
        var p1 = this.UpdateSubjects();
        var p2 = this.ChangeSubject(config.subject);
        var p3 = this.ChangeTheme(config.theme);
        var p4 = this.ChangeCategory(config.category);
        var p5 = this.ChangeIndicators(config.filters, config.value);
        var p6 = this.ChangeGeography(config.geography);
        Promise.all([p1, p2, p3, p4, p5, p6]).then(function (c) {
          _this2.UpdateRenderer().then(function (c) {
            _this2.Commit();

            _this2.Emit("Idle");

            d.Resolve();
          }, function (error) {
            return d.Reject(error);
          });
        }, function (error) {
          return d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "Clone",
      value: function Clone(pojo) {
        return JSON.parse(JSON.stringify(pojo));
      }
    }, {
      key: "Commit",
      value: function Commit() {
        this.lookups.previous = this.Clone(this.lookups.current);
        this.selection.previous = this.Clone(this.selection.current);
        this._metadata.previous = this.Clone(this._metadata.current);
        this._sublayer.previous = this._sublayer.current;
      }
    }, {
      key: "Revert",
      value: function Revert() {
        this.lookups.current = this.Clone(this.lookups.previous);
        this.selection.current = this.Clone(this.selection.previous);
        this._metadata.current = this.Clone(this._metadata.previous);
        this._sublayer.current = this._sublayer.previous;
      }
    }, {
      key: "UpdateSubjects",
      value: function UpdateSubjects() {
        var _this3 = this;

        return Requests.Indicator(null).then(function (lookup) {
          _this3.lookups.current.subjects = lookup;
        }, function (error) {
          return _this3.OnContext_Error(error);
        });
      }
    }, {
      key: "UpdateThemes",
      value: function UpdateThemes() {
        var _this4 = this;

        return Requests.Indicator(this.subject).then(function (lookup) {
          _this4.lookups.current.themes = lookup;
        }, function (error) {
          return _this4.OnContext_Error(error);
        });
      }
    }, {
      key: "UpdateCategories",
      value: function UpdateCategories() {
        var _this5 = this;

        return Requests.Indicator(this.theme).then(function (lookup) {
          _this5.lookups.current.categories = lookup;
        }, function (error) {
          return _this5.OnContext_Error(error);
        });
      }
    }, {
      key: "UpdateIndicators",
      value: function UpdateIndicators() {
        var _this6 = this;

        return Requests.Category(this.category).then(function (r) {
          _this6.lookups.current.filters = r.filters; //.map(f => f.values);

          _this6.lookups.current.values = r.value; //.values;
        }, function (error) {
          return _this6.OnContext_Error(error);
        });
      }
    }, {
      key: "UpdateMetadata",
      value: function UpdateMetadata() {
        var _this7 = this;

        var d = Core.Defer();
        Requests.Metadata(this.indicators).then(function (metadata) {
          _this7.metadata = metadata;

          _this7.UpdateGeographies().then(function (items) {
            return d.Resolve();
          }, function (error) {
            return d.Reject(error);
          });
        }, function (error) {
          return d.Reject(error);
        });
        return d.promise;
      }
    }, {
      key: "UpdateGeographies",
      value: function UpdateGeographies() {
        var _this8 = this;

        return Requests.Geography(this.metadata.indicator).then(function (items) {
          _this8.lookups.current.geographies = items;
        }, function (error) {
          return _this8.OnContext_Error(error);
        });
      }
    }, {
      key: "UpdateRenderer",
      value: function UpdateRenderer() {
        var _this9 = this;

        return Requests.Renderer(this).then(function (sublayer) {
          _this9.sublayer = sublayer;
        }, function (error) {
          return _this9.OnContext_Error(error);
        });
      }
    }, {
      key: "ChangeSubject",
      value: function ChangeSubject(subject) {
        this.subject = subject;
        return this.UpdateThemes();
      }
    }, {
      key: "ChangeTheme",
      value: function ChangeTheme(theme) {
        this.theme = theme;
        return this.UpdateCategories();
      }
    }, {
      key: "ChangeCategory",
      value: function ChangeCategory(category) {
        this.category = category;
        return this.UpdateIndicators();
      }
    }, {
      key: "ChangeIndicators",
      value: function ChangeIndicators(filters, value) {
        this.filters = filters;
        this.value = value;
        return this.UpdateMetadata();
      }
    }, {
      key: "ChangeGeography",
      value: function ChangeGeography(geography) {
        var d = Core.Defer();
        d.Resolve(this);
        this.geography = geography;
        return d.promise;
      }
    }, {
      key: "Lookup",
      value: function Lookup(id) {
        return this.lookups.current[id];
      }
    }, {
      key: "FindLookupItem",
      value: function FindLookupItem(lookup, value) {
        for (var i = 0; i &lt; lookup.length; i++) {
          if (lookup[i].value == value) return lookup[i];
        }

        return null;
      }
    }, {
      key: "IndicatorItems",
      value: function IndicatorItems() {
        var _this10 = this;

        var items = this.filters.map(function (ind, i) {
          var lookup = _this10.Lookup("filters")[i];

          return _this10.FindLookupItem(lookup.values, ind);
        });
        items.push(this.FindLookupItem(this.Lookup("values"), this.value));
        return items;
      }
    }, {
      key: "IndicatorsLabel",
      value: function IndicatorsLabel() {
        // TODO : Couple of things here, removing the first term because reference period
        // didn't show in the original app. Also removing the numbers at the start of each
        // label because they start with numbers.
        return this.IndicatorItems().splice(1).map(function (i) {
          return i.label.split(" ").splice(1).join(" ");
        }).join(", ");
      }
    }, {
      key: "OnContext_Error",
      value: function OnContext_Error(error) {
        this.Emit("Error", {
          error: error
        });
      }
    }]);

    return Context;
  }(Evented);

  var Map = /*#__PURE__*/function (_Evented) {
    _inherits(Map, _Evented);

    var _super = _createSuper(Map);

    function Map(container) {
      var _this;

      _classCallCheck(this, Map);

      _this = _super.call(this);
      _this.layers = {};
      _this.behaviors = {};
      _this.map = new ESRI.Map({
        basemap: "streets"
      });
      _this.view = new ESRI.views.MapView({
        animation: false,
        center: [-100, 63],
        container: container,
        map: _this.map,
        zoom: 4
      });
      _this.view.popup.collapseEnabled = false;

      _this.view.on("click", _this.OnMapView_Click.bind(_assertThisInitialized(_this)));

      var fullscreen = new ESRI.widgets.Fullscreen({
        view: _this.view
      });

      _this.view.ui.add(fullscreen, "top-left");

      return _this;
    }

    _createClass(Map, [{
      key: "Popup",
      get: function get() {
        return this.view.popup;
      }
    }, {
      key: "AddBehavior",
      value: function AddBehavior(id, behavior) {
        this.behaviors[id] = behavior;
        return behavior;
      }
    }, {
      key: "Behavior",
      value: function Behavior(id) {
        return this.behaviors[id] || null;
      } // NOTE : Test for spread operator in Rollup

    }, {
      key: "Place",
      value: function Place(elements, position) {
        var _this2 = this;

        elements.forEach(function (e) {
          return _this2.view.ui.add(e, position);
        });
      }
    }, {
      key: "AddGraphicsLayer",
      value: function AddGraphicsLayer(id) {
        var layer = new ESRI.layers.GraphicsLayer();
        this.layers[id] = layer;
        this.map.add(layer);
      }
    }, {
      key: "AddFeatureLayer",
      value: function AddFeatureLayer(id, url, labels, visibility) {
        // FIX: Naming convention, we've been using camelCase for variables
        // so first letter lowercase then each other word uppercase
        var FLayer = new ESRI.layers.FeatureLayer({
          url: url,
          fields: [{
            name: id,
            alias: labels
          }],
          visible: visibility
        }); // FIX: Address TODO, delete if not relevant anymore
        // TODO

        this.layers[id] = FLayer;
        this.map.add(FLayer);
      }
    }, {
      key: "AddMapImageLayer",
      value: function AddMapImageLayer(id, url, opacity, dpi, format) {
        if (this.layers[id]) throw new Error("Layer already exists in map.");
        var layer = new ESRI.layers.MapImageLayer({
          url: url,
          imageFormat: format || 'png8',
          opacity: opacity || 1,
          dpi: dpi || 96,
          sublayers: []
        });
        this.layers[id] = layer;
        this.map.add(layer);
      }
    }, {
      key: "EmptyLayer",
      value: function EmptyLayer(id) {
        this.Layer(id).sublayers.removeAll();
      }
    }, {
      key: "AddSubLayer",
      value: function AddSubLayer(id, sublayer) {
        // FIX: Address TODO, delete if not relevant anymore
        // TODO : try After Add
        this.Layer(id).sublayers.add(sublayer);
      }
    }, {
      key: "AddSubLayers",
      value: function AddSubLayers(id, sublayers) {
        this.Layer(id).sublayers.addMany(sublayer);
      }
    }, {
      key: "Layer",
      value: function Layer(id) {
        return this.layers[id] || null;
      }
    }, {
      key: "Identify",
      value: function Identify(layer, geometry) {
        var _this3 = this;

        var d = Core.Defer();
        Requests.Identify(layer, geometry).then(function (result) {
          d.Resolve(result);
        }, function (error) {
          return _this3.OnMapView_Error(error);
        });
        return d.promise;
      }
    }, {
      key: "GoTo",
      value: function GoTo(target) {
        this.view.goTo(target);
      }
    }, {
      key: "OnMapView_Click",
      value: function OnMapView_Click(ev) {
        this.Emit("Click", ev);
      }
    }, {
      key: "OnMapView_Error",
      value: function OnMapView_Error(ev) {
        this.Emit("Error", ev);
      }
    }]);

    return Map;
  }(Evented);

  var Behavior = /*#__PURE__*/function (_Evented) {
    _inherits(Behavior, _Evented);

    var _super = _createSuper(Behavior);

    function Behavior(map, options) {
      _classCallCheck(this, Behavior);

      return _super.call(this);
    }

    _createClass(Behavior, [{
      key: "Deactivate",
      value: function Deactivate() {
        throw new Error("Deactivate must be implemented by inheriting class.");
      }
    }, {
      key: "Activate",
      value: function Activate() {
        throw new Error("Activate must be implemented by inheriting class.");
      }
    }]);

    return Behavior;
  }(Evented);

  var RectangleSelectBehavior = /*#__PURE__*/function (_Behavior) {
    _inherits(RectangleSelectBehavior, _Behavior);

    var _super = _createSuper(RectangleSelectBehavior);

    function RectangleSelectBehavior(map, options) {
      var _this;

      _classCallCheck(this, RectangleSelectBehavior);

      _this = _super.call(this);
      _this.options = {};
      _this.map = map;
      _this.draw = new ESRI.views.draw.Draw({
        view: _this.map.view
      });
      _this.action = null;

      _this.map.AddGraphicsLayer('selection');

      _this.Reset(options);

      _this.handlers = {
        "cursor-update": null,
        "draw-complete": null
      };
      return _this;
    }

    _createClass(RectangleSelectBehavior, [{
      key: "Layer",
      get: function get() {
        return this.map.Layer('selection');
      }
    }, {
      key: "Graphics",
      get: function get() {
        return this.Layer.graphics;
      }
    }, {
      key: "Deactivate",
      value: function Deactivate() {
        this.Clear();
        this.handlers["cursor-update"].remove();
        this.handlers["draw-complete"].remove();
      }
    }, {
      key: "Activate",
      value: function Activate() {
        this.action = this.draw.create("rectangle", {
          mode: "click"
        });
        this.handlers["cursor-update"] = this.action.on(["cursor-update"], this.OnDraw_CursorUpdate.bind(this));
        this.handlers["draw-complete"] = this.action.on(["draw-complete"], this.OnDraw_Complete.bind(this));
      }
    }, {
      key: "Reset",
      value: function Reset(options) {
        this.Clear();
        if (options.layer) this.options.layer = options.layer; // Layer to query when done selecting

        if (options.field) this.options.field = options.field; // Field used to compare graphics

        if (options.symbol) this.options.symbol = options.symbol; // Symbol to draw the graphics with
      }
    }, {
      key: "Clear",
      value: function Clear() {
        this.Layer.removeAll();
        this.map.view.graphics.removeAll();
      }
    }, {
      key: "VerticesToPolygon",
      value: function VerticesToPolygon(vertices, sref) {
        var p1 = vertices[0];
        var p2 = vertices[1]; // points are [x, y] format

        var ring = [p1, [p2[0], p1[1]], p2, [p1[0], p2[1]], p1];
        return {
          type: "polygon",
          rings: [ring],
          spatialReference: sref
        };
      }
    }, {
      key: "OnDraw_CursorUpdate",
      value: function OnDraw_CursorUpdate(ev) {
        if (ev.vertices.length &lt; 2) return;
        this.map.view.graphics.removeAll();
        var geometry = this.VerticesToPolygon(ev.vertices, this.map.view.spatialReference);
        var outline = {
          color: [200, 20, 0],
          width: 1
        };
        var symbol = {
          type: "simple-fill",
          color: [200, 20, 0, 0.3],
          style: "solid",
          outline: outline
        };
        this.map.view.graphics.add(new ESRI.Graphic({
          geometry: geometry,
          symbol: symbol
        }));
      }
    }, {
      key: "OnDraw_Complete",
      value: function OnDraw_Complete(ev) {
        var _this2 = this;

        this.Emit("Busy");
        this.map.view.graphics.removeAll();
        if (ev.vertices.length &lt; 2) return;
        var geometry = this.VerticesToPolygon(ev.vertices, this.map.view.spatialReference);
        var p = Requests.QueryGeometry(this.options.layer, geometry);
        p.then(this.OnDraw_QueryComplete.bind(this), function (error) {
          return _this2.OnDraw_QueryError.bind(_this2);
        });
      }
    }, {
      key: "OnDraw_QueryComplete",
      value: function OnDraw_QueryComplete(results) {
        var _this3 = this;

        results.features.forEach(function (f) {
          var exists = _this3.Layer.graphics.find(function (g) {
            return g.attributes[_this3.options.field] == f.attributes[_this3.options.field];
          });

          if (exists) _this3.Layer.remove(exists);else {
            f.symbol = _this3.options.symbol;

            _this3.Layer.graphics.add(f);
          }
        });
        this.Emit("Idle");
        this.Emit("Change", {
          selection: this.Layer.graphics
        });
        this.Activate();
      }
    }, {
      key: "OnDraw_QueryError",
      value: function OnDraw_QueryError(error) {
        this.Emit("Error", {
          error: error
        });
        this.Emit("Idle");
      }
    }]);

    return RectangleSelectBehavior;
  }(Behavior);

  var PointIdentifyBehavior = /*#__PURE__*/function (_Behavior) {
    _inherits(PointIdentifyBehavior, _Behavior);

    var _super = _createSuper(PointIdentifyBehavior);

    function PointIdentifyBehavior(map, options) {
      var _this;

      _classCallCheck(this, PointIdentifyBehavior);

      _this = _super.call(this);
      _this.options = {};
      _this.map = map;

      _this.map.AddGraphicsLayer('identify');

      _this.Reset(options);

      _this.ClickHandler = _this.OnMap_Click.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(PointIdentifyBehavior, [{
      key: "Layer",
      get: function get() {
        return this.map.Layer("identify");
      }
    }, {
      key: "Graphics",
      get: function get() {
        return this.Layer.graphics;
      }
    }, {
      key: "Deactivate",
      value: function Deactivate() {
        this.Clear();
        this.map.Off("Click", this.ClickHandler);
      }
    }, {
      key: "Activate",
      value: function Activate() {
        this.map.On("Click", this.ClickHandler);
      }
    }, {
      key: "Reset",
      value: function Reset(options) {
        this.Clear();
        if (options.layer) this.options.layer = options.layer; // Layer to query when done selecting

        if (options.symbol) this.options.symbol = options.symbol; // Symbol to draw the graphics with
      }
    }, {
      key: "Clear",
      value: function Clear() {
        this.Layer.removeAll();
        this.map.Popup.close();
      }
    }, {
      key: "OnMap_Click",
      value: function OnMap_Click(ev) {
        var _this2 = this;

        this.Emit("Busy");
        this.map.Identify(this.options.layer, ev.mapPoint).then(function (r) {
          _this2.Emit("Idle");

          _this2.Layer.removeAll();

          r.feature.symbol = _this2.options.symbol;

          _this2.Layer.add(r.feature);

          _this2.map.Popup.open({
            title: r.title,
            content: r.content,
            location: ev.mapPoint
          });

          _this2.Emit("Change", {
            mapPoint: ev.mapPoint,
            results: r
          });
        }, function (error) {
          return _this2.OnIdentify_Error(error);
        });
      }
    }, {
      key: "OnIdentify_Error",
      value: function OnIdentify_Error(error) {
        this.Emit("Error", {
          error: error
        });
        this.Emit("Idle");
      }
    }]);

    return PointIdentifyBehavior;
  }(Behavior);

  var Menu = /*#__PURE__*/function () {
    function Menu() {
      _classCallCheck(this, Menu);

      this.current = null;
      this.items = {};
    }

    _createClass(Menu, [{
      key: "Buttons",
      get: function get() {
        var buttons = [];

        for (var id in this.items) {
          buttons.push(this.items[id].button);
        }

        return buttons;
      }
    }, {
      key: "Item",
      value: function Item(id) {
        return this.items[id];
      }
    }, {
      key: "Button",
      value: function Button(id) {
        return this.Item(id).button;
      }
    }, {
      key: "Overlay",
      value: function Overlay(id) {
        return this.Item[id].overlay;
      }
    }, {
      key: "AddItem",
      value: function AddItem(id, item) {
        if (this.items.hasOwnProperty(id)) throw new Error("Item with id ".concat(id, " already exists in menu."));
        this.items[id] = item;
      }
    }, {
      key: "AddButton",
      value: function AddButton(id, title) {
        var item = {
          button: Dom.Create("button", {
            title: title,
            className: "button-icon large-icon ".concat(id)
          })
        };
        this.AddItem(id, item);
      }
    }, {
      key: "AddOverlay",
      value: function AddOverlay(id, title, overlay) {
        var item = {
          button: Dom.Create("button", {
            title: title,
            className: "button-icon large-icon ".concat(id)
          }),
          overlay: overlay
        };
        this.AddItem(id, item);
        item.button.addEventListener("click", this.OnMenuButton_Click.bind(this, item));
        overlay.On("Close", this.OnOverlay_Hide.bind(this, item));
      }
    }, {
      key: "OnMenuButton_Click",
      value: function OnMenuButton_Click(item, ev) {
        this.SetOverlay(item);
      }
    }, {
      key: "OnOverlay_Hide",
      value: function OnOverlay_Hide(item, ev) {
        this.HideOverlay(item);
        this.current = null;
      }
    }, {
      key: "SetOverlay",
      value: function SetOverlay(item) {
        if (this.current) this.HideOverlay(this.current);
        this.current = this.current == item ? null : item;
        if (this.current) this.ShowOverlay(this.current);
      }
    }, {
      key: "HideOverlay",
      value: function HideOverlay(item) {
        item.overlay.Hide();
        Dom.RemoveCss(item.button, "checked");
      }
    }, {
      key: "ShowOverlay",
      value: function ShowOverlay(item) {
        item.overlay.Show();
        Dom.AddCss(item.button, "checked");
      }
    }]);

    return Menu;
  }();

  var Overlay = /*#__PURE__*/function (_Templated) {
    _inherits(Overlay, _Templated);

    var _super = _createSuper(Overlay);

    function Overlay(container) {
      var _this;

      _classCallCheck(this, Overlay);

      _this = _super.call(this, container);

      _this.SetStyle(0, "hidden");

      _this.Node("close").On("click", _this.onBtnClose_Click.bind(_assertThisInitialized(_this)));

      Dom.AddCss(_this.container, "overlay");
      return _this;
    }

    _createClass(Overlay, [{
      key: "Title",
      set: function set(value) {
        this.Elem("title").innerHTML = value;
      }
    }, {
      key: "Widget",
      get: function get() {
        return this.widget;
      },
      set: function set(widget) {
        this.Empty();
        this.widget = widget;
        widget.Place(this.Elem("body"));
      }
    }, {
      key: "SetStyle",
      value: function SetStyle(opacity, visibility) {
        //this.Elem("overlay").style.opacity = opacity;
        //this.Elem("overlay").style.visibility = visibility;
        this.container.style.opacity = opacity;
        this.container.style.visibility = visibility;
      }
    }, {
      key: "Empty",
      value: function Empty() {
        Dom.Empty(this.Elem("body"));
      }
    }, {
      key: "Show",
      value: function Show() {
        this.SetStyle(1, "visible");
        this.Emit("Show", {
          overlay: this
        });
        this.Elem("close").focus();
      }
    }, {
      key: "Hide",
      value: function Hide() {
        this.SetStyle(0, "hidden");
        this.Emit("Hide", {
          overlay: this
        });
      }
    }, {
      key: "onBtnClose_Click",
      value: function onBtnClose_Click(ev) {
        this.Hide();
        this.Emit("Close", {
          overlay: this
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        //return "&lt;div handle='overlay' class='overlay hidden'>" +
        return "&lt;div class='overlay-header'>" + "&lt;h2 class='overlay-title' handle='title'>&lt;/h2>" + "&lt;button class='overlay-close' handle='close' title='nls(Overlay_Close)'>×&lt;/button>" + "&lt;/div>" + "&lt;div class='overlay-body' handle='body'>&lt;/div>"; //	   "&lt;/div>";
      }
    }]);

    return Overlay;
  }(Templated);

  var Select = Core.Templatable("Basic.Components.Select", /*#__PURE__*/function (_Templated) {
    _inherits(Select, _Templated);

    var _super = _createSuper(Select);

    function Select(container, options) {
      var _this;

      _classCallCheck(this, Select);

      _this = _super.call(this, container, options);
      _this.items = [];
      _this.ph = null;

      _this.Node("root").On("change", _this.OnSelect_Change.bind(_assertThisInitialized(_this)));

      return _this;
    }

    _createClass(Select, [{
      key: "value",
      get: function get() {
        return this.Elem("root").value;
      },
      set: function set(value) {
        this.Elem("root").value = value;
      }
    }, {
      key: "disabled",
      get: function get() {
        return this.Elem("root").disabled;
      },
      set: function set(value) {
        this.Elem("root").disabled = value;
      }
    }, {
      key: "selected",
      get: function get() {
        var i = this.Elem("root").value;
        return this.items[i];
      }
    }, {
      key: "placeholder",
      set: function set(value) {
        this.ph = Dom.Create("option", {
          innerHTML: value,
          value: -1,
          className: "select-placeholder"
        });
        this.ph.disabled = true;
        this.ph.selected = true;
        this.Elem("root").insertBefore(this.ph, this.Elem("root").firstChild);
      }
    }, {
      key: "Add",
      value: function Add(label, title, item) {
        Dom.Create("option", {
          innerHTML: label,
          value: this.items.length,
          title: title
        }, this.Elem("root"));
        this.items.push(item);
      }
    }, {
      key: "Select",
      value: function Select(delegate) {
        this.value = this.FindIndex(delegate);
      }
    }, {
      key: "FindIndex",
      value: function FindIndex(delegate) {
        for (var i = 0; i &lt; this.items.length; i++) {
          if (delegate(this.items[i], i)) return i;
        }

        return -1;
      }
    }, {
      key: "OnSelect_Change",
      value: function OnSelect_Change(ev) {
        var item = this.items[ev.target.value];
        this.Emit("Change", {
          index: ev.target.value,
          item: item,
          label: ev.target.innerHTML
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return '&lt;select handle="root">&lt;/select>';
      }
    }, {
      key: "Empty",
      value: function Empty() {
        Dom.Empty(this.Elem("root"));
        this.items = [];
        if (!this.ph) return;
        Dom.Place(this.ph, this.Elem("root"));
        this.ph.selected = true;
      }
    }]);

    return Select;
  }(Templated));

  Core.Templatable("App.Widgets.Selector", /*#__PURE__*/function (_Overlay) {
    _inherits(Selector, _Overlay);

    var _super = _createSuper(Selector);

    function Selector(container, options) {
      var _this;

      _classCallCheck(this, Selector);

      _this = _super.call(this, container, options);
      _this.filters = [];
      _this.metadata = null;

      _this.Node("sSubject").On("Change", _this.OnSubject_Change.bind(_assertThisInitialized(_this)));

      _this.Node("sTheme").On("Change", _this.OnTheme_Change.bind(_assertThisInitialized(_this)));

      _this.Node("sCategory").On("Change", _this.OnCategory_Change.bind(_assertThisInitialized(_this)));

      _this.Node("sValue").On("Change", _this.OnValue_Change.bind(_assertThisInitialized(_this)));

      _this.Node("sGeography").On("Change", _this.OnGeography_Change.bind(_assertThisInitialized(_this)));

      _this.Node("bApply").On("click", _this.OnApply_Click.bind(_assertThisInitialized(_this)));

      _this.Node("bClose").On("click", _this.OnClose_Click.bind(_assertThisInitialized(_this)));

      _this.Elem('sSubject').placeholder = Core.Nls("Selector_Subject_Placeholder");
      _this.Elem('sTheme').placeholder = Core.Nls("Selector_Theme_Placeholder");
      _this.Elem('sCategory').placeholder = Core.Nls("Selector_Category_Placeholder");
      _this.Elem('sValue').placeholder = Core.Nls("Selector_Value_Placeholder");
      _this.Elem('sGeography').placeholder = Core.Nls("Selector_Geography_Placeholder");
      _this.Elem('sTheme').disabled = true;
      _this.Elem('sCategory').disabled = true;
      _this.Elem('sValue').disabled = true;
      _this.Elem('sGeography').disabled = true;
      _this.Elem('bApply').disabled = true;
      return _this;
    }

    _createClass(Selector, [{
      key: "Update",
      value: function Update(context) {
        this.context = context;
        this.LoadDropDown(this.Elem("sSubject"), context.Lookup("subjects"));
        this.LoadDropDown(this.Elem("sTheme"), context.Lookup("themes"));
        this.LoadDropDown(this.Elem("sCategory"), context.Lookup("categories"));
        this.LoadDropDown(this.Elem("sGeography"), context.Lookup("geographies"));
        this.LoadDropDown(this.Elem('sValue'), context.Lookup("values"));
        this.LoadFilters(context.Lookup("filters"));
        this.Elem("sSubject").Select(function (i) {
          return i.value == context.subject;
        });
        this.Elem("sTheme").Select(function (i) {
          return i.value == context.theme;
        });
        this.Elem("sCategory").Select(function (i) {
          return i.value == context.category;
        });
        this.Elem("sGeography").Select(function (i) {
          return i.value == context.geography;
        });
        this.Elem("sValue").Select(function (i) {
          return i.value == context.value;
        });
        this.filters.forEach(function (f, i) {
          f.Select(function (j) {
            return j.value == context.filters[i];
          });
        });
      }
    }, {
      key: "LoadDropDown",
      value: function LoadDropDown(select, items) {
        select.Empty();
        items.forEach(function (item) {
          return select.Add(item.label, item.description, item);
        });
        select.disabled = false;
      }
    }, {
      key: "ResetFilter",
      value: function ResetFilter() {
        this.filters = [];
        Dom.Empty(this.Elem('filter'));
        Dom.RemoveCss(this.Elem("instructions"), "hidden");
      }
    }, {
      key: "LoadFilters",
      value: function LoadFilters(filters) {
        var _this2 = this;

        Dom.AddCss(this.Elem("instructions"), "hidden");
        this.filters = filters.map(function (d) {
          Dom.Create("label", {
            innerHTML: d.label
          }, _this2.Elem('filter'));
          var div = Dom.Create("div", null, _this2.Elem('filter'));
          var select = new Select(div);
          d.values.forEach(function (item) {
            return select.Add(item.label, null, item);
          });
          select.Elem("root").firstChild.selected = true;
          select.On("Change", _this2.OnValue_Change.bind(_this2));
          return select;
        });
      }
    }, {
      key: "Disable",
      value: function Disable(elements) {
        var _this3 = this;

        elements.forEach(function (e) {
          _this3.Elem(e).disabled = true;
          _this3.Elem(e).value = -1;
        });
        if (elements.indexOf('sValue') == -1) return;
        this.ResetFilter();
      }
    }, {
      key: "OnSubject_Change",
      value: function OnSubject_Change(ev) {
        var _this4 = this;

        this.Disable(['sTheme', 'sCategory', 'sValue', 'sGeography', 'bApply']);
        this.Emit("Busy");
        this.context.ChangeSubject(ev.item.value).then(function (c) {
          _this4.Emit("Idle");

          _this4.LoadDropDown(_this4.Elem("sTheme"), _this4.context.Lookup("themes"));
        }, function (error) {
          return _this4.OnRequests_Error(error);
        });
      }
    }, {
      key: "OnTheme_Change",
      value: function OnTheme_Change(ev) {
        var _this5 = this;

        this.Disable(['sCategory', 'sValue', 'sGeography', 'bApply']);
        this.Emit("Busy");
        this.context.ChangeTheme(ev.item.value).then(function (c) {
          _this5.Emit("Idle");

          _this5.LoadDropDown(_this5.Elem("sCategory"), _this5.context.Lookup("categories"));
        }, function (error) {
          return _this5.OnRequests_Error(error);
        });
      }
    }, {
      key: "OnCategory_Change",
      value: function OnCategory_Change(ev) {
        var _this6 = this;

        this.Disable(['sValue', 'sGeography', 'bApply']);
        this.Emit("Busy");
        this.context.ChangeCategory(ev.item.value).then(function (c) {
          _this6.Emit("Idle");

          _this6.LoadFilters(_this6.context.Lookup("filters"));

          _this6.LoadDropDown(_this6.Elem("sValue"), _this6.context.Lookup("values"));
        }, function (error) {
          return _this6.OnRequests_Error(error);
        });
      }
    }, {
      key: "OnValue_Change",
      value: function OnValue_Change(ev) {
        var _this7 = this;

        if (this.Elem("sValue").value == -1) return;
        this.Disable(['sGeography', 'bApply']);
        var filters = this.filters.map(function (f) {
          return f.selected.value;
        });
        var value = this.Elem("sValue").selected.value;
        this.Emit("Busy");
        this.context.ChangeIndicators(filters, value).then(function (c) {
          _this7.Emit("Idle");

          _this7.LoadDropDown(_this7.Elem("sGeography"), _this7.context.Lookup("geographies"));
        }, function (error) {
          return _this7.OnRequests_Error(error);
        });
      }
    }, {
      key: "OnGeography_Change",
      value: function OnGeography_Change(ev) {
        this.Elem('bApply').disabled = false;
        this.context.ChangeGeography(ev.item.value);
      }
    }, {
      key: "OnApply_Click",
      value: function OnApply_Click(ev) {
        var _this8 = this;

        this.Emit("Busy");
        this.context.UpdateRenderer().then(function (c) {
          _this8.Emit("Idle");

          _this8.context.Commit();

          _this8.Emit("Change", {
            context: _this8.context
          });
        });
      }
    }, {
      key: "OnClose_Click",
      value: function OnClose_Click(ev) {
        this.context.Revert();
        this.Update(this.context);
        this.Hide();
      }
    }, {
      key: "OnRequests_Error",
      value: function OnRequests_Error(error) {
        this.Emit("Error", {
          error: error
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='overlay-header'>" + "&lt;h2 class='overlay-title' handle='title'>nls(Selector_Title)&lt;/h2>" + "&lt;button class='overlay-close' handle='close' title='nls(Overlay_Close)'>×&lt;/button>" + "&lt;/div>" + "&lt;hr>" + "&lt;div class='overlay-body' handle='body'>" + "&lt;label class='sm-label'>nls(Selector_Subject)&lt;/label>" + "&lt;div handle='sSubject' widget='Basic.Components.Select'>&lt;/div>" + "&lt;label class='sm-label'>nls(Selector_Theme)&lt;/label>" + "&lt;div handle='sTheme' widget='Basic.Components.Select'>&lt;/div>" + "&lt;label>nls(Selector_Category)&lt;/label>" + "&lt;div handle='sCategory' widget='Basic.Components.Select'>&lt;/div>" + "&lt;div class='filter-container'>" + "&lt;label>nls(Selector_Filter_Label)&lt;/label>" + "&lt;div handle='instructions' class='filter-instructions'>nls(Selector_Filter_Instructions)&lt;/div>" + "&lt;div handle='filter' class='filter'>&lt;/div>" + "&lt;/div>" + "&lt;label>nls(Selector_Value)&lt;/label>" + "&lt;div handle='sValue' widget='Basic.Components.Select'>&lt;/div>" + "&lt;label>nls(Selector_Geography)&lt;/label>" + "&lt;div handle='sGeography' widget='Basic.Components.Select'>&lt;/div>" + "&lt;div class='button-container'>" + "&lt;button handle='bApply' class='button-label button-apply'>nls(Selector_Button_Apply)&lt;/button>" + "&lt;button handle='bClose' class='button-label button-close'>nls(Selector_Button_Close)&lt;/button>" + "&lt;/div>" + "&lt;/div>";
      }
    }]);

    return Selector;
  }(Overlay));

  var Axes = /*#__PURE__*/function () {
    function Axes() {
      _classCallCheck(this, Axes);
    }

    _createClass(Axes, null, [{
      key: "CreateBandXScale",
      value: function CreateBandXScale(data, innerWidth) {
        return d3.scaleBand() // Map values into correct pixel positions
        .domain(data.map(function (d) {
          return d.title;
        })) // Map values from start of data array to end of data array
        .range([0, innerWidth]).padding(0.1);
      }
    }, {
      key: "CreateLinearXScale",
      value: function CreateLinearXScale(data, innerWidth) {
        return d3.scaleLinear().domain([0, data.length - 1]).range([0, innerWidth]);
      }
    }, {
      key: "CreateLinearYScale",
      value: function CreateLinearYScale(data, innerHeight) {
        // Could also use .domain(d3.extent(data, (d) => d.value ))
        return d3.scaleLinear() // max at the top of the y-axis
        // 0 at the bottom of the y-axis
        .domain([d3.max(data, function (d) {
          return d.value;
        }), 0]) // 0 on bottom of y-axis
        // max at top of y-axis
        .range([0, innerHeight]) // .nice() rounds the domain to nice values
        .nice();
      } // Horizontal lines onto graph 

    }, {
      key: "GridLineY",
      value: function GridLineY(yScale, innerWidth) {
        return d3.axisLeft(yScale) // left axis should have same number of ticks 
        .tickSize(-innerWidth).ticks().tickFormat("");
      }
    }, {
      key: "AppendGridLineForY",
      value: function AppendGridLineForY(yScale, innerWidth, g) {
        var y = this.GridLineY(yScale, innerWidth);
        g.append('g').call(y).classed("y axis-grid", true).attr("transform", "translate(0,0)");
      }
    }, {
      key: "UpdateGridLineForY",
      value: function UpdateGridLineForY(yScale, innerWidth, g) {
        var y = this.GridLineY(yScale, innerWidth);
        g.selectAll("g.y.axis-grid").call(y).attr("transform", "translate(0,0)");
      } // Vertical lines onto graph

    }, {
      key: "GridLineX",
      value: function GridLineX(xScale, innerHeight) {
        return d3.axisBottom(xScale).tickSize(-innerHeight).tickFormat("");
      }
    }, {
      key: "AppendGridLineForX",
      value: function AppendGridLineForX(xScale, innerHeight, g) {
        var x = this.GridLineX(xScale, innerHeight);
        g.append('g').call(x).classed("x axis-grid", true).attr('transform', 'translate(0,' + innerHeight + ')');
      }
    }, {
      key: "UpdateGridLineForX",
      value: function UpdateGridLineForX(xScale, innerHeight, g) {
        var x = this.GridLineX(xScale, innerHeight);
        g.selectAll("g.x.axis-grid").call(x).attr('transform', 'translate(0,' + innerHeight + ')');
      } // Vertical axis

    }, {
      key: "AppendLeftAxisToGraph",
      value: function AppendLeftAxisToGraph(yScale, g) {
        g.append('g').call(d3.axisLeft(yScale).ticks()).classed("y axis", true);
      }
    }, {
      key: "UpdateLeftAxisToGraph",
      value: function UpdateLeftAxisToGraph(yScale, g) {
        g.selectAll('g.y.axis').call(d3.axisLeft(yScale).ticks());
      } // Horizontal axis

    }, {
      key: "AppendBottomAxisToGraph",
      value: function AppendBottomAxisToGraph(xScale, innerHeight, g) {
        this.SetBottomAxisAttributes(xScale, innerHeight, g.append("g").classed("x axis", true));
      }
    }, {
      key: "UpdateBottomAxisInGraph",
      value: function UpdateBottomAxisInGraph(xScale, innerHeight, g) {
        this.SetBottomAxisAttributes(xScale, innerHeight, g.selectAll("g.x.axis"));
      }
    }, {
      key: "SetBottomAxisAttributes",
      value: function SetBottomAxisAttributes(xScale, innerHeight, g) {
        g.call(d3.axisBottom(xScale)).attr("transform", "translate(0, ".concat(innerHeight, ")")).selectAll("text").attr("transform", "translate(-10,0)rotate(-45)").text(function (d) {
          if (d.length >= 16) {
            d = d.substring(0, 13) + "...";
          }

          return d;
        }).style("text-anchor", "end");
      }
    }]);

    return Axes;
  }();

  var Chart = /*#__PURE__*/function () {
    function Chart(options) {
      _classCallCheck(this, Chart);

      this.options = options;
      this.spaceFromBorders = 25;
      this.tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 1);
      this.SelectContainerElement();
      this.AppendSVGtoContainerElement();
      this.SetDimensions();
      this.AddGroupToSVG();
    }

    _createClass(Chart, [{
      key: "SelectContainerElement",
      value: function SelectContainerElement() {
        this.container = d3.select(this.options.element);
      }
    }, {
      key: "AppendSVGtoContainerElement",
      value: function AppendSVGtoContainerElement() {
        this.container.append("svg").attr("width", +this.options.element.getAttribute("width")).attr("height", +this.options.element.getAttribute("height"));
      }
    }, {
      key: "SetDimensions",
      value: function SetDimensions() {
        var dimensions = this.options.dimensions || false;

        if (!dimensions) {
          var margin = {
            top: 20,
            bottom: 70,
            right: 0,
            left: 55
          };
          var width = +this.container.select("svg").attr("width") - this.spaceFromBorders;
          var height = +this.container.select("svg").attr("height") - this.spaceFromBorders;
          dimensions = {
            margin: margin,
            width: width,
            height: height,
            innerWidth: width - margin.left - margin.right,
            innerHeight: height - margin.top - margin.bottom
          };

          if (this.options.chartType == "PieChart") {
            dimensions.radius = Math.min(width, height) / 3;
            dimensions.width += this.spaceFromBorders;
          }
        }

        this.dimensions = dimensions;
      }
    }, {
      key: "UpdateMargin",
      value: function UpdateMargin(top, bottom, right, left) {
        this.dimensions.margin = {
          top: top,
          bottom: bottom,
          right: right,
          left: left
        };
      }
    }, {
      key: "UpdateWidth",
      value: function UpdateWidth(width) {
        this.dimensions.width = width;
      }
    }, {
      key: "UpdateHeight",
      value: function UpdateHeight(height) {
        this.dimensions.height = height;
      }
    }, {
      key: "UpdateInnerWidth",
      value: function UpdateInnerWidth(innerWidth) {
        this.dimensions.innerWidth = innerWidth;
      }
    }, {
      key: "UpdateInnerHeight",
      value: function UpdateInnerHeight(innerHeight) {
        this.dimensions.innerHeight = innerHeight;
      } // Put the group within the view of the svg 

    }, {
      key: "AddGroupToSVG",
      value: function AddGroupToSVG() {
        this.g = this.container.select("svg").append('g');

        if (this.options.chartType == "BarChart" || this.options.chartType == "LineChart" || this.options.chartType == "ScatterPlot") {
          this.g.attr('transform', "translate(".concat(this.dimensions.margin.left, ", ").concat(this.dimensions.margin.top, ")"));
        } else if (this.options.chartType == "PieChart") {
          // TODO: The centering could use some work
          this.g.attr('transform', "translate(".concat(this.dimensions.width / 2, ", ").concat(this.dimensions.radius, ")"));
        }
      }
    }, {
      key: "BuildScales",
      value: function BuildScales() {
        if (this.options.chartType == "LineChart" || this.options.chartType == "ScatterPlot") {
          this.xScale = Axes.CreateLinearXScale(this.options.data, this.dimensions.innerWidth);
        } else {
          this.xScale = Axes.CreateBandXScale(this.options.data, this.dimensions.innerWidth);
        }

        this.yScale = Axes.CreateLinearYScale(this.options.data, this.dimensions.innerHeight);
      } // To build axes you need scales first

    }, {
      key: "BuildAxes",
      value: function BuildAxes() {
        this.BuildScales();

        if (this.options.chartType == "LineChart" || this.options.chartType == "ScatterPlot") {
          Axes.AppendGridLineForX(this.xScale, this.dimensions.innerHeight, this.g);
        }

        Axes.AppendGridLineForY(this.yScale, this.dimensions.innerWidth, this.g);
        Axes.AppendLeftAxisToGraph(this.yScale, this.g);
        Axes.AppendBottomAxisToGraph(this.xScale, this.dimensions.innerHeight, this.g);
      }
    }, {
      key: "UpdateAxes",
      value: function UpdateAxes() {
        var xScaleDomain;

        if (this.options.chartType == "LineChart" || this.options.chartType == "ScatterPlot") {
          xScaleDomain = this.xScale.domain([0, this.options.data.length - 1]);
        } else {
          xScaleDomain = this.xScale.domain(this.options.data.map(function (d) {
            return d.title;
          }));
        }

        Axes.UpdateBottomAxisInGraph(xScaleDomain, this.dimensions.innerHeight, this.g);
        Axes.UpdateLeftAxisToGraph(this.yScale.domain([d3.max(this.options.data, function (d) {
          return d.value;
        }), 0]), this.g);
        Axes.UpdateGridLineForY(this.yScale, this.dimensions.innerWidth, this.g);

        if (this.options.chartType == "LineChart") {
          Axes.UpdateGridLineForX(this.xScale, this.dimensions.innerHeight, this.g);
        }
      } // Based on overlay
      // TODO

    }, {
      key: "Resize",
      value: function Resize() {} // Use tooltip.js instead?

    }, {
      key: "MouseOver",
      value: function MouseOver(d) {
        this.tooltip.transition().delay(100).duration(600).style("opacity", 1).style('pointer-events', 'all');

        if (this.options.chartType == "PieChart") {
          this.tooltip.html("".concat(d.data.title) + "&lt;br/>" + "Value: " + "".concat(d.data.value)).style("left", d3.event.pageX + "px").style("top", d3.event.pageY - 28 + "px");
        } else {
          this.tooltip.html("".concat(d.title) + "&lt;br/>" + "Value: " + "".concat(d.value)).style("left", d3.event.pageX + "px").style("top", d3.event.pageY - 28 + "px");
        }
      }
    }, {
      key: "MouseOut",
      value: function MouseOut() {
        this.tooltip.transition().delay(100).duration(600).style("opacity", 0).style('pointer-events', 'none');
      }
    }]);

    return Chart;
  }();

  var BarChart = /*#__PURE__*/function (_Chart) {
    _inherits(BarChart, _Chart);

    var _super = _createSuper(BarChart);

    function BarChart(options) {
      var _this;

      _classCallCheck(this, BarChart);

      _this = _super.call(this, options);
      _this.options = options;
      _this.color = d3.scaleOrdinal(d3.schemeCategory20);

      _this.Draw();

      return _this;
    }

    _createClass(BarChart, [{
      key: "Draw",
      value: function Draw() {
        this.BuildAxes();
        this.AppendVerticalRectanglesToGraph();
      } // This is specific to regular bar graphs
      // A sideways bar graph would need a new method entirely

    }, {
      key: "AppendVerticalRectanglesToGraph",
      value: function AppendVerticalRectanglesToGraph() {
        var _this2 = this;

        var rectangles = this.g.selectAll("rect").data(this.options.data);
        var self = this;
        rectangles.enter().append("rect").merge(rectangles).attr("x", function (d) {
          return _this2.xScale(d.title);
        }).attr("y", this.yScale(0)) // Compute the width for each rectangle
        .attr("width", this.xScale.bandwidth()) // Compute height for each rectangle
        .attr("height", this.dimensions.innerHeight - this.yScale(0)) // Later fill based on SME config
        .style("fill", function (d) {
          return _this2.color(d.value);
        }) // So rectangles can change on hover
        .on("mouseover", function (d) {
          d3.select(this).style("opacity", 0.5);
          self.MouseOver(d);
        }).on("mouseout", function () {
          d3.select(this).style("opacity", 1);
          self.MouseOut();
        }); // Remove surplus bars and previous dataset out of graph

        rectangles.exit().remove(); // Rectangles will grow up to their innerHeight

        this.TransitionOnTheY();
      }
    }, {
      key: "TransitionOnTheY",
      value: function TransitionOnTheY() {
        var _this3 = this;

        this.g.selectAll("rect").transition().duration(700).ease(d3.easeLinear).attr("y", function (d) {
          return _this3.yScale(d.value);
        }).attr("height", function (d) {
          return _this3.dimensions.innerHeight - _this3.yScale(d.value);
        });
      } // Based on adding or removing features 

    }, {
      key: "Redraw",
      value: function Redraw() {
        // Scale domains must be redone since the axises 
        // and bars and grid lines need to change 
        this.UpdateAxes();
        this.AppendVerticalRectanglesToGraph();
      }
    }]);

    return BarChart;
  }(Chart);

  Core.Templatable("App.Widgets.WChart", /*#__PURE__*/function (_Overlay) {
    _inherits(WChart, _Overlay);

    var _super = _createSuper(WChart);

    function WChart(container, options) {
      var _this;

      _classCallCheck(this, WChart);

      _this = _super.call(this, container, options);
      _this.metadata = null;
      _this.chart = null; // Will be based on SME decision

      _this.chartType = null;
      return _this;
    }

    _createClass(WChart, [{
      key: "data",
      get: function get() {
        return this._data;
      },
      set: function set(value) {
        this.PopulateDataArray(value);
      }
    }, {
      key: "PopulateDataArray",
      value: function PopulateDataArray(value) {
        var title = Core.Nls("DisplayNameLong");
        this._data = [];

        for (var index = 0; index &lt; value.length; index++) {
          var element = value[index];

          this._data.push({
            title: element["attributes"][title],
            value: element["attributes"]["Value"]
          });
        }

        this.Chart();
      }
    }, {
      key: "Chart",
      value: function Chart() {
        // If the chart has already been made
        if (this.chart) {
          // If no more data, clear the chart from the overlay
          if (this._data.length == 0) {
            this.ClearChart();
          } // If the chart exists and more data has been added, redraw
          else {
              this.chart.options.data = this._data;
              this.chart.Redraw();
            }
        } // Create the chart
        else if (this._data.length != 0) {
            var element = this.Node("ChartsContainer").elem; // Uncomment whichever chart you want to see
            // TODO: Define chart type in constructor instead?
            // TODO: Prevent user from selecting too much (or hide x axis labels)

            this.chart = new BarChart({
              chartType: "BarChart",
              data: this._data,
              element: element
            }); // TODO: Add new square DIV for legend with label and multiline 
            // https://www150.statcan.gc.ca/n1/pub/71-607-x/71-607-x2018012-eng.htm
            // this.chart = new PieChart({
            //   chartType: "PieChart",
            //   data: this._data,
            //   element: element
            // });
            // TODO: Add red line tooltip instead of hover
            // https://www150.statcan.gc.ca/n1/pub/71-607-x/71-607-x2017003-eng.htm
            // The x-axis labels are numbers
            // this.chart = new LineChart({
            //   chartType: "LineChart",
            //   data: this._data,
            //   element: element
            // });
            // Need better data for testing of LineChart and 
            // ScatterPlot
            // this.chart = new ScatterPlot({
            //   chartType: "ScatterPlot",
            //   data: this._data,
            //   element: element
            // });
          }
      }
    }, {
      key: "ClearChart",
      value: function ClearChart() {
        var svg = d3.select(this.Node("ChartsContainer").elem);
        svg.selectAll("svg").remove();
        this.chart = null;
      }
    }, {
      key: "OnRequests_Error",
      value: function OnRequests_Error(error) {
        this.Emit("Error", {
          error: error
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='overlay-header'>" + "&lt;h2 class='overlay-title' handle='title'>nls(Chart_Title)&lt;/h2>" + "&lt;button class='overlay-close' handle='close' title='nls(Overlay_Close)'>×&lt;/button>" + "&lt;/div>" + "&lt;hr>" + "&lt;div class='overlay-body' handle='body'>" + //"&lt;label class='sm-label'>nls(Chart_Type)&lt;/label>" +
        "&lt;div id='ChartsContainer' handle='ChartsContainer' width='430' height='400'>&lt;/div>" + "&lt;/div>" + "&lt;/div>";
      }
    }]);

    return WChart;
  }(Overlay));

  Core.Templatable("Basic.Components.Picker", /*#__PURE__*/function (_Templated) {
    _inherits(Picker, _Templated);

    var _super = _createSuper(Picker);

    function Picker(container) {
      var _this;

      _classCallCheck(this, Picker);

      _this = _super.call(this, container);
      _this.h = null;
      _this.collapsed = true;

      _this.Node("button").On("click", _this.OnButtonColor_Click.bind(_assertThisInitialized(_this)));

      _this.Node("container").On("click", _this.OnContainer_Click.bind(_assertThisInitialized(_this)));

      _this.picker = new iro.ColorPicker(_this.Elem('wheel'), {
        width: 170,
        layoutDirection: "vertical",
        sliderSize: 15
      }); // this.picker.on("color:change", this.OnPicker_Change.bind(this));

      _this.picker.base.children[0].tabIndex = 0;
      _this.picker.base.children[1].tabIndex = 0;
      _this.Elem('button').style.backgroundColor = _this.picker.color.rgbString;
      _this.onBody_KeyUp_Bound = _this.onBody_KeyUp.bind(_assertThisInitialized(_this));
      _this.onBody_Click_Bound = _this.onBody_Click.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(Picker, [{
      key: "color",
      get: function get() {
        return this.picker.color;
      },
      set: function set(value) {
        this.picker.color.set(value);
        this.Elem('button').style.backgroundColor = this.picker.color.rgbString;
      }
    }, {
      key: "EsriColor",
      get: function get() {
        var c = this.color.rgba;
        return [c.r, c.g, c.b, c.a * 255];
      }
    }, {
      key: "OnContainer_Click",
      value: function OnContainer_Click(ev) {
        ev.stopPropagation();
      } // OnPicker_Change(ev) {
      //	this.Elem('button').style.backgroundColor = this.picker.color.rgbString;
      // }

    }, {
      key: "OnButtonColor_Click",
      value: function OnButtonColor_Click(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this.collapsed ? this.Show() : this.Hide();
      }
    }, {
      key: "Show",
      value: function Show() {
        document.body.addEventListener("keyup", this.onBody_KeyUp_Bound);
        document.body.addEventListener("click", this.onBody_Click_Bound);
        this.collapsed = false;
        Dom.RemoveCss(this.Elem('container'), "collapsed");
      }
    }, {
      key: "Hide",
      value: function Hide() {
        document.body.removeEventListener("keyup", this.onBody_KeyUp_Bound);
        document.body.removeEventListener("click", this.onBody_Click_Bound);
        this.collapsed = true;
        Dom.AddCss(this.Elem('container'), "collapsed");
        this.Elem('button').style.backgroundColor = this.picker.color.rgbString;
        this.Emit("Finished", {
          color: this.picker.color.rgba
        });
      }
    }, {
      key: "onBody_KeyUp",
      value: function onBody_KeyUp(ev) {
        if (ev.keyCode == 27) this.Hide();
      }
    }, {
      key: "onBody_Click",
      value: function onBody_Click(ev) {
        this.Hide();
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='color-picker'>" + "&lt;button handle='button' class='color'>&lt;/button>" + "&lt;div handle='container' class='wheel-container collapsed'>" + "&lt;div handle='wheel'>&lt;/div>" + "&lt;/div>" + "&lt;/div>";
      }
    }]);

    return Picker;
  }(Templated));

  var templatedTable = /*#__PURE__*/function (_Templated) {
    _inherits(templatedTable, _Templated);

    var _super = _createSuper(templatedTable);

    function templatedTable() {
      _classCallCheck(this, templatedTable);

      return _super.apply(this, arguments);
    }

    _createClass(templatedTable, [{
      key: "BuildTemplate",
      value: function BuildTemplate() {
        // Use template provided in options first, use Template function second
        var html = this.options.template ? this.options.template : this.Template(); // TODO : I think it still works with empty templates.

        if (!html) return; // Trailing whitespaces can cause issues when parsing the template, remove them

        html = html.trim(); // Replace all nls strings in template. Nls string pattern in templates is nls(StringId)

        html = this.Replace(html, /nls\((.*?)\)/, function (m) {
          return Core.Nls(m);
        });
        this.template = Dom.Create("tbody", {
          innerHTML: html
        });
      }
    }]);

    return templatedTable;
  }(Templated);

  var StylerBreak = Core.Templatable("App.Widgets.StylerBreak", /*#__PURE__*/function (_TemplatedTable) {
    _inherits(StylerBreak, _TemplatedTable);

    var _super = _createSuper(StylerBreak);

    function StylerBreak(container, info) {
      var _this;

      _classCallCheck(this, StylerBreak);

      _this = _super.call(this, container, info);
      _this.Min = info.minValue;
      _this.Max = info.maxValue;
      _this.color = info.symbol.color;
      _this.Elem("color").style.backgroundColor = _this.color.toHex();

      _this.Elem("bTo").addEventListener("click", _this.OnEditor_Button.bind(_assertThisInitialized(_this)));

      _this.Elem("eApply").addEventListener("click", _this.OnEditor_Apply.bind(_assertThisInitialized(_this)));

      _this.Elem("eCancel").addEventListener("click", _this.OnEditor_Cancel.bind(_assertThisInitialized(_this)));

      _this.Elem("eRemove").addEventListener("click", _this.OnEditor_Remove.bind(_assertThisInitialized(_this)));

      return _this;
    }

    _createClass(StylerBreak, [{
      key: "Min",
      get: function get() {
        return this.min;
      },
      set: function set(value) {
        this.min = value;
        this.Elem("lFrom").innerHTML = this.min.toLocaleString(Core.locale);
      }
    }, {
      key: "Max",
      get: function get() {
        return this.max;
      },
      set: function set(value) {
        this.max = value;
        this.Elem("bTo").innerHTML = this.max.toLocaleString(Core.locale);
        this.Elem("eInput").value = this.max;
      }
    }, {
      key: "Color",
      get: function get() {
        return this.color;
      }
    }, {
      key: "Cancel",
      value: function Cancel() {
        this.Elem("eInput").value = this.max;
      }
    }, {
      key: "Save",
      value: function Save() {
        this.max = +this.Elem("eInput").value;
        this.Elem("bTo").innerHTML = this.max.toLocaleString(Core.locale);
      }
    }, {
      key: "Edit",
      value: function Edit() {
        Dom.AddCss(this.Elem('eContainer'), "editing");
      }
    }, {
      key: "StopEdit",
      value: function StopEdit() {
        Dom.RemoveCss(this.Elem('eContainer'), "editing");
      }
    }, {
      key: "OnEditor_Button",
      value: function OnEditor_Button(ev) {
        this.Edit();
      }
    }, {
      key: "OnEditor_Apply",
      value: function OnEditor_Apply(ev) {
        var tentative = +this.Elem("eInput").value;
        this.Emit("apply", {
          value: tentative
        });
      }
    }, {
      key: "OnEditor_Cancel",
      value: function OnEditor_Cancel(ev) {
        this.Cancel();
        this.StopEdit();
      }
    }, {
      key: "OnEditor_Remove",
      value: function OnEditor_Remove(ev) {
        this.Emit("remove");
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;tr handle='container' class='break-line'>" + "&lt;td class='break-color-container'>" + "&lt;div handle='color' class='break-color'>&lt;/div>" + "&lt;/td>" + "&lt;td handle='lFrom'>&lt;/td>" + "&lt;td>nls(Styler_Item_Join)&lt;/td>" + "&lt;td handle='eContainer' class='break-to-container'>" + "&lt;button handle='bTo' class='to'>&lt;/button>" + "&lt;button handle='eRemove' class= 'remove button-icon small-icon'>&lt;/button>" + "&lt;div class='editor'>" + "&lt;input handle='eInput' class='editor-input' type='number'>" + "&lt;button handle='eApply' class='apply button-icon small-icon'>&lt;/button>" + "&lt;button handle='eCancel' class='cancel button-icon small-icon'>&lt;/button>" + "&lt;/div>" + "&lt;/td>" + "&lt;/tr>";
      }
    }]);

    return StylerBreak;
  }(templatedTable));

  Core.Templatable("App.Widgets.Styler", /*#__PURE__*/function (_Overlay) {
    _inherits(Styler, _Overlay);

    var _super = _createSuper(Styler);

    function Styler(container, options) {
      var _this;

      _classCallCheck(this, Styler);

      _this = _super.call(this, container, options);
      _this.metadata = null;
      _this.breaks = null;

      _this.Elem('sMethod').Add(Core.Nls("Styler_Method_Equal"), null, {
        id: 1,
        algo: "esriClassifyEqualInterval"
      });

      _this.Elem('sMethod').Add(Core.Nls("Styler_Method_Natural"), null, {
        id: 2,
        algo: "esriClassifyNaturalBreaks"
      });

      _this.Elem('sMethod').Add(Core.Nls("Styler_Method_Quantile"), null, {
        id: 3,
        algo: "esriClassifyQuantile"
      });

      _this.Node('bColorS').On("Finished", _this.OnPicker_Finished.bind(_assertThisInitialized(_this)));

      _this.Node('bColorE').On("Finished", _this.OnPicker_Finished.bind(_assertThisInitialized(_this)));

      var handler = function (ev) {
        this.onIBreaks_Change(ev);
      }.bind(_assertThisInitialized(_this));

      _this.Node('iBreaks').On("change", Core.Debounce(handler, 350));

      _this.Node('sMethod').On("Change", _this.onMethod_Change.bind(_assertThisInitialized(_this)));

      _this.Node("bApply").On("click", _this.OnApply_Click.bind(_assertThisInitialized(_this)));

      _this.Node("bClose").On("click", _this.OnClose_Click.bind(_assertThisInitialized(_this)));

      return _this;
    }

    _createClass(Styler, [{
      key: "Update",
      value: function Update(context) {
        this.context = context;
        var n = context.sublayer.renderer.classBreakInfos.length;
        var idx = this.Elem('sMethod').FindIndex(function (i) {
          return i.algo === context.metadata.breaks.algo;
        });
        this.Elem("sMethod").value = idx;
        this.Elem("iBreaks").value = n;
        this.Elem("bColorS").color = context.sublayer.renderer.classBreakInfos[0].symbol.color;
        this.Elem("bColorE").color = context.sublayer.renderer.classBreakInfos[n - 1].symbol.color;
        this.LoadClassBreaks(context.sublayer.renderer.classBreakInfos);
      }
    }, {
      key: "Remove",
      value: function Remove(i) {
        var brk = this.breaks[i];
        var prev = this.breaks[i - 1];
        var next = this.breaks[i + 1];
        if (next &amp;&amp; prev) next.Min = prev.Max; // TODO: implement this in DOM (eventually?)

        this.Elem('breaks').removeChild(brk.Elem('container'));
        this.breaks.splice(i, 1);
        this.Elem("iBreaks").value = this.breaks.length;
      }
    }, {
      key: "LoadClassBreaks",
      value: function LoadClassBreaks(classBreakInfos) {
        var _this2 = this;

        Dom.Empty(this.Elem("breaks"));
        this.breaks = classBreakInfos.map(function (c, i) {
          var brk = new StylerBreak(_this2.Elem('breaks'), c);
          brk.On("apply", _this2.OnBreak_Apply.bind(_this2, i));
          brk.On("remove", _this2.OnBreak_Remove.bind(_this2, i));
          return brk;
        });
      }
    }, {
      key: "OnBreak_Apply",
      value: function OnBreak_Apply(i, ev) {
        var curr = this.breaks[i];
        var next = this.breaks[i + 1];
        if (next &amp;&amp; ev.value > next.Max) alert(Core.Nls("Styler_Max_Gt_Next"));else if (ev.value &lt; curr.Min) alert(Core.Nls("Styler_Max_Lt_Min"));else {
          ev.target.Save();
          ev.target.StopEdit();
          next.Min = curr.Max;
        }
      }
    }, {
      key: "OnBreak_Remove",
      value: function OnBreak_Remove(i, ev) {
        // Last break cannot be removed
        if (this.breaks.length == 1) return;
        var i = this.breaks.indexOf(ev.target);
        this.Remove(i);
      }
    }, {
      key: "OnPicker_Finished",
      value: function OnPicker_Finished(ev) {
        this.context.metadata.colors.start = this.Elem("bColorS").EsriColor;
        this.context.metadata.colors.end = this.Elem("bColorE").EsriColor;
        this.Refresh();
      }
    }, {
      key: "onIBreaks_Change",
      value: function onIBreaks_Change(ev) {
        this.context.metadata.breaks.n = ev.target.value;
        this.Refresh();
      }
    }, {
      key: "onMethod_Change",
      value: function onMethod_Change(ev) {
        this.context.metadata.breaks.algo = ev.target.selected.algo;
        this.Refresh();
      }
    }, {
      key: "OnApply_Click",
      value: function OnApply_Click(ev) {
        var _this3 = this;

        this.context.Commit();
        var json = this.context.sublayer.renderer.toJSON();
        json.min = this.breaks[0].min;
        var symbol = this.context.sublayer.renderer.classBreakInfos[0].symbol;
        this.breaks.map(function (b) {
          json.classBreakInfos = _this3.breaks.map(function (b) {
            symbol.color = b.Color;
            return {
              description: "",
              label: "".concat(b.Min, " - ").concat(b.Max),
              classMaxValue: b.Max,
              symbol: symbol.toJSON()
            };
          });
        });
        var renderer = ESRI.renderers.support.jsonUtils.fromJSON(json);
        this.Emit("Change", {
          renderer: renderer
        });
      }
    }, {
      key: "OnClose_Click",
      value: function OnClose_Click(ev) {
        this.context.Revert();
        this.Hide();
        this.Update(this.context);
      }
    }, {
      key: "OnRequests_Error",
      value: function OnRequests_Error(error) {
        this.Emit("Error", {
          error: error
        });
      }
    }, {
      key: "Refresh",
      value: function Refresh() {
        var _this4 = this;

        this.Emit("Busy");
        Requests.Renderer(this.context).then(function (sublayer) {
          _this4.Emit("Idle");

          _this4.LoadClassBreaks(sublayer.renderer.classBreakInfos);
        }, function (error) {
          return _this4.OnRequests_Error(error);
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='overlay-header'>" + "&lt;h2 class='overlay-title' handle='title'>nls(Styler_Title)&lt;/h2>" + "&lt;button class='overlay-close' handle='close' title='nls(Overlay_Close)'>×&lt;/button>" + "&lt;/div>" + "&lt;hr>" + "&lt;div class='overlay-body' handle='body'>" + "&lt;p>nls(Styler_Instructions_1)&lt;/p>" + "&lt;label>nls(Styler_Method)&lt;/label>" + "&lt;div handle='sMethod' widget='Basic.Components.Select'>&lt;/div>" + "&lt;label>nls(Styler_Breaks)&lt;/label>" + "&lt;input handle='iBreaks' type='number' min='1' max='10' />" + "&lt;label>nls(Styler_Color_Range)&lt;/label>" + "&lt;div class='color-range'>" + "&lt;label>nls(Styler_Color_Start)&lt;/label>" + "&lt;div handle='bColorS' class='color start' widget='Basic.Components.Picker'>&lt;/div>" + "&lt;label>nls(Styler_Color_End)&lt;/label>" + "&lt;div handle='bColorE' class='color end' widget='Basic.Components.Picker'>&lt;/div>" + "&lt;/div>" + "&lt;label>nls(Styler_Style)&lt;/label>" + "&lt;table handle='breaks' class='breaks-container'>" + // Class breaks go here, dynamically created
        "&lt;/table>" + "&lt;p>nls(Styler_Instructions_3)&lt;/p>" + "&lt;div class='button-container'>" + "&lt;button handle='bApply' class='button-label button-apply'>nls(Selector_Button_Apply)&lt;/button>" + "&lt;button handle='bClose' class='button-label button-close'>nls(Selector_Button_Close)&lt;/button>" + "&lt;/div>" + "&lt;/div>";
      }
    }]);

    return Styler;
  }(Overlay));

  var LegendBreak = Core.Templatable("App.Widgets.LegendBreak", /*#__PURE__*/function (_TemplatedTable) {
    _inherits(LegendBreak, _TemplatedTable);

    var _super = _createSuper(LegendBreak);

    function LegendBreak(container, info) {
      var _this;

      _classCallCheck(this, LegendBreak);

      _this = _super.call(this, container, info);
      _this.Min = info.minValue;
      _this.Max = info.maxValue;
      _this.color = info.symbol.color;
      _this.Elem("color").style.backgroundColor = _this.color.toHex();
      return _this;
    }

    _createClass(LegendBreak, [{
      key: "Min",
      get: function get() {
        return this.min;
      },
      set: function set(value) {
        this.min = value;
        this.Elem("lFrom").innerHTML = this.min.toLocaleString(Core.locale);
      }
    }, {
      key: "Max",
      get: function get() {
        return this.max;
      },
      set: function set(value) {
        this.max = value;
        this.Elem("lTo").innerHTML = this.max.toLocaleString(Core.locale);
      }
    }, {
      key: "Color",
      get: function get() {
        return this.color;
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;tr handle='container' class='break-line'>" + "&lt;td class='break-color-container'>" + "&lt;div handle='color' class='break-color'>&lt;/div>" + "&lt;/td>" + "&lt;td handle='lFrom'>&lt;/td>" + "&lt;td>nls(Styler_Item_Join)&lt;/td>" + "&lt;td handle='lTo'>&lt;/td>" + "&lt;/tr>";
      }
    }]);

    return LegendBreak;
  }(templatedTable));

  Core.Templatable("App.Widgets.Legend", /*#__PURE__*/function (_Overlay) {
    _inherits(Legend, _Overlay);

    var _super = _createSuper(Legend);

    function Legend(container, options) {
      var _this;

      _classCallCheck(this, Legend);

      _this = _super.call(this, container, options);

      _this.Node('sOpacity').On("change", _this.OnOpacity_Changed.bind(_assertThisInitialized(_this))); // FIX: Since this part of the legend is static, we should do all of this through the 
      // template at the bottom then hook events onto already built DOM elements. 
      // Hard-coded strings should not be used, breaks translation.


      _this.AddLabelName({
        label: " Show Label Name"
      });

      return _this;
    }

    _createClass(Legend, [{
      key: "Opacity",
      get: function get() {
        return this.Elem('sOpacity').value / 100;
      },
      set: function set(value) {
        this.Elem('sOpacity').value = value * 100;
      }
    }, {
      key: "Update",
      value: function Update(context) {
        this.context = context;
        this.LoadIndicators(context.IndicatorItems());
        this.LoadClassBreaks(context.sublayer.renderer.classBreakInfos);
      }
    }, {
      key: "LoadIndicators",
      value: function LoadIndicators(indicators) {
        var _this2 = this;

        Dom.Empty(this.Elem("indicators"));
        indicators.forEach(function (i) {
          Dom.Create("li", {
            innerHTML: i.label
          }, _this2.Elem("indicators"));
        });
      }
    }, {
      key: "LoadClassBreaks",
      value: function LoadClassBreaks(classBreakInfos) {
        var _this3 = this;

        Dom.Empty(this.Elem("breaks"));
        this.breaks = classBreakInfos.map(function (c, i) {
          return new LegendBreak(_this3.Elem('breaks'), c);
        });
      }
    }, {
      key: "AddContextLayer",
      value: function AddContextLayer(label, data, checked) {
        var _this4 = this;

        var div = Dom.Create("li", {
          className: "context-layer"
        }, this.Elem("cLayers"));
        var chk = Dom.Create("input", {
          id: Core.NextId(),
          className: "context-layer-check",
          type: "checkbox",
          checked: checked
        }, div);
        Dom.Create("label", {
          htmlFor: chk.id,
          className: "context-layer-label",
          innerHTML: label
        }, div);
        chk.addEventListener("change", function (ev) {
          _this4.Emit("LayerVisibility", {
            data: data,
            checked: chk.checked
          });
        });
      }
    }, {
      key: "AddLabelName",
      value: function AddLabelName(item) {
        var _this5 = this;

        var div = Dom.Create("li", {
          className: "labelName"
        }, this.Elem("labelName"));
        var chk = Dom.Create("input", {
          id: Core.NextId(),
          className: "labelName-checkbox",
          type: "checkbox"
        }, div);
        Dom.Create("label", {
          htmlFor: chk.id,
          className: "labelName-label",
          innerHTML: item.label
        }, div);
        chk.addEventListener("change", function (ev) {
          _this5.Emit("LabelVisibility", {
            checked: chk.checked
          });
        });
      }
    }, {
      key: "OnOpacity_Changed",
      value: function OnOpacity_Changed(ev) {
        this.Emit("Opacity", {
          opacity: this.Opacity
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='overlay-header'>" + "&lt;h2 class='overlay-title' handle='title'>nls(Legend_Title)&lt;/h2>" + "&lt;button class='overlay-close' handle='close' title='nls(Overlay_Close)'>×&lt;/button>" + "&lt;/div>" + "&lt;div class='overlay-body' handle='body'>" + "&lt;label>nls(Legend_Indicators)&lt;/label>" + "&lt;ul handle='indicators'>&lt;/ul>" + "&lt;label>nls(Legend_Title)&lt;/label>" + "&lt;table handle='breaks' class='breaks-container'>" + // Class breaks go here, dynamically created
        "&lt;/table>" + "&lt;label>nls(Legend_Opacity)&lt;/label>" + "&lt;div class='opacity-container'>" + "&lt;input handle='sOpacity' type='range' class='opacity' min=0 max=100 />" + "&lt;div class='opacity-labels-container'>" + "&lt;label>nls(Legend_Opacity_Less)&lt;/label>" + "&lt;label>nls(Legend_Opacity_More)&lt;/label>" + "&lt;/div>" + "&lt;/div>" + "&lt;label>nls(Legend_Context_Layers)&lt;/label>" + "&lt;ul handle='cLayers' class='context-layers-container'>" + "&lt;/div>" + "&lt;label>nls(Legend_Label_Name)&lt;/label>" + "&lt;ul handle='labelName' class='label-name-container'>" + "&lt;/div>";
      }
    }]);

    return Legend;
  }(Overlay));

  var Typeahead = Core.Templatable("Basic.Components.Typeahead", /*#__PURE__*/function (_Templated) {
    _inherits(Typeahead, _Templated);

    var _super = _createSuper(Typeahead);

    function Typeahead(container, options) {
      var _this;

      _classCallCheck(this, Typeahead);

      _this = _super.call(this, container, options);
      _this._store = null;
      _this._items = null;
      _this._filt = null;
      _this._curr = null;
      _this._temp = null;

      var handler = function (ev) {
        this.OnInputInput_Handler(ev);
      }.bind(_assertThisInitialized(_this));

      _this.Node("input").On("input", Core.Debounce(handler, 350)); // this.Node("input").On("click", this.OnInputClick_Handler.bind(this));


      _this.Node("input").On("keydown", function (ev) {
        this.OnInputKeyDown_Handler(ev);
      }.bind(_assertThisInitialized(_this)));

      _this.Node("input").On("blur", function (ev) {
        this.OnInputBlur_Handler(ev);
      }.bind(_assertThisInitialized(_this)));

      _this.Node("input").On("focusin", function (ev) {
        this.OnInputClick_Handler(ev);
      }.bind(_assertThisInitialized(_this))); // this.Node("input").On("focusout", this.OnInputBlur_Handler.bind(this));


      if (!options) return _possibleConstructorReturn(_this);
      _this.items = options.items;
      return _this;
    }

    _createClass(Typeahead, [{
      key: "placeholder",
      set: function set(value) {
        this.Elem('input').setAttribute('placeholder', value);
      }
    }, {
      key: "title",
      set: function set(value) {
        this.Elem('input').setAttribute('title', value);
      }
    }, {
      key: "store",
      set: function set(value) {
        var _this2 = this;

        this._store = value.map(function (i) {
          var li = Dom.Create("li", {
            innerHTML: i.label,
            tabIndex: -1
          });
          var item = {
            data: i,
            node: li,
            next: null,
            prev: null
          };
          li.addEventListener("mousedown", _this2.onLiClick_Handler.bind(_this2, item));
          return item;
        }); // Initially unfiltered

        this._items = this._store;
      }
    }, {
      key: "current",
      get: function get() {
        return this._curr;
      },
      set: function set(value) {
        this._curr = value;
      }
    }, {
      key: "Empty",
      value: function Empty() {
        Dom.Empty(this.Elem("list"));
        this._items = [];
      }
    }, {
      key: "Refresh",
      value: function Refresh() {
        throw new Error("The Refresh function must be implemented.");
      }
    }, {
      key: "Fill",
      value: function Fill(items, mask) {
        this._items = items;
        var frag = document.createDocumentFragment();

        for (var i = 0; i &lt; items.length; i++) {
          var curr = items[i]; // Maybe insert &lt;b> at right index instead, faster?

          curr.node.innerHTML = curr.data.label.replace(mask, "&lt;b>".concat(mask, "&lt;/b>"));
          curr.next = items[(i + 1) % items.length];
          curr.next.prev = curr;
          Dom.Place(curr.node, frag);
        }

        Dom.Place(frag, this.Elem("list"));
      }
    }, {
      key: "UpdateCss",
      value: function UpdateCss() {
        Dom.ToggleCss(this.Elem("root"), "collapsed", this._items.length == 0);
      }
    }, {
      key: "Reset",
      value: function Reset() {
        if (this._temp) Dom.SetCss(this._temp.node, "");
        this._temp = null;
        this.Empty();
        var value = this.current ? this.current.data.label : "";
        this.Elem("input").value = value;
      }
    }, {
      key: "OnInputInput_Handler",
      value: function OnInputInput_Handler(ev) {
        var _this3 = this;

        var value = ev.target.value; // var value = this.Elem("input").value;	// If can'T use ...args in debounce

        if (value.length &lt; 3) return;
        this.Empty();
        this.Refresh(value).then(function (items) {
          _this3.Fill(items, value);

          _this3.UpdateCss();
        });
      }
    }, {
      key: "OnInputClick_Handler",
      value: function OnInputClick_Handler(ev) {
        var _this4 = this;

        if (ev.target.value.length &lt; 3) return;
        this.Refresh(ev.target.value).then(function (items) {
          _this4.Fill(items, ev.target.value);

          _this4.UpdateCss();
        });
      }
    }, {
      key: "OnInputKeyDown_Handler",
      value: function OnInputKeyDown_Handler(ev) {
        // prevent default event on specifically handled keys
        if (ev.keyCode == 40 || ev.keyCode == 38 || ev.keyCode == 13 || ev.keyCode == 27) ev.preventDefault(); // shift + up : select text

        if (ev.shiftKey == true &amp;&amp; ev.keyCode == 38) this.nodes.Input.select(); // up or down key : cycle through dropdown
        else if (ev.keyCode == 40 || ev.keyCode == 38) {
            this._temp = this._temp || this._items[this._items.length - 1];
            Dom.SetCss(this._temp.node, "");
            this._temp = ev.keyCode == 40 ? this._temp.next : this._temp.prev;
            this.Elem("input").value = this._temp.data.label;
            this.ScrollTo(this._temp);
            Dom.SetCss(this._temp.node, "active");
          } // enter : select currently focused
          else if (ev.keyCode == 13) {
              // if an item is currently selected through arrows, select that one
              if (this._temp) this.onLiClick_Handler(this._temp); // if a filtered list is being shown, select the first item
              else if (this._items.length > 0) this.onLiClick_Handler(this._items[0]); // nothing is selected (don't think this can happen		    	
                else {
                    this.OnInputClick_Handler({
                      target: this.Elem("input")
                    });
                  }
            } // if escape key
            else if (ev.keyCode == 27) this.OnInputBlur_Handler();
      }
    }, {
      key: "OnInputBlur_Handler",
      value: function OnInputBlur_Handler(ev) {
        this.Reset();
        this.UpdateCss();
      }
    }, {
      key: "onLiClick_Handler",
      value: function onLiClick_Handler(item, ev) {
        ev.stopPropagation(); // ev.preventDefault();

        this.current = item;
        this.Reset();
        this.UpdateCss();
        this.Emit("Change", {
          item: item.data
        });
      }
    }, {
      key: "ScrollTo",
      value: function ScrollTo(item) {
        // create rectangules to know the position of the elements
        var ul = this.Elem("list");
        var liBx = item.node.getBoundingClientRect();
        var ulBx = ul.getBoundingClientRect(); //if the element is in this range then it is inside the main container, don't scroll

        if (liBx.bottom > ulBx.bottom) ul.scrollTop = ul.scrollTop + liBx.bottom - ulBx.top - ulBx.height;else if (liBx.top &lt; ulBx.top) ul.scrollTop = ul.scrollTop + liBx.top - ulBx.top;
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div handle='root' class='typeahead collapsed'>" + "&lt;input handle='input' type='text' class='input' placeholder='nls(Search_Typeahead_Placeholder)' title='nls(Search_Typeahead_Title)'>" + "&lt;ul handle='list' class='list'>&lt;/ul>" + "&lt;/div>";
      }
    }]);

    return Typeahead;
  }(Templated));

  Core.Templatable("Basic.Components.DynamicTypeahead", /*#__PURE__*/function (_Typeahead) {
    _inherits(DynamicTypeahead, _Typeahead);

    var _super = _createSuper(DynamicTypeahead);

    function DynamicTypeahead(container, options) {
      _classCallCheck(this, DynamicTypeahead);

      return _super.call(this, container, options);
    }

    _createClass(DynamicTypeahead, [{
      key: "storeFn",
      set: function set(value) {
        this._storeFn = value;
      }
    }, {
      key: "Refresh",
      value: function Refresh(mask) {
        var _this = this;

        var d = Core.Defer();
        Dom.AddCss(this.Elem("root"), "loading");

        this._storeFn(mask).then(function (items) {
          Dom.RemoveCss(_this.Elem("root"), "loading");
          _this.store = items;
          d.Resolve(_this._items);
        }, function (error) {
          d.Reject(error);
        });

        return d.promise;
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div handle='root' class='typeahead collapsed'>" + "&lt;input handle='input' type='text' class='input' placeholder='nls(Search_Typeahead_Placeholder)' title='nls(Search_Typeahead_Title)'>" + "&lt;img class='wait' src='./assets/loading.svg' alt='nls(Search_Typeahead_loading'>" + "&lt;ul handle='list' class='list'>&lt;/ul>" + "&lt;/div>";
      }
    }]);

    return DynamicTypeahead;
  }(Typeahead));

  Core.Templatable("App.Widgets.Search", /*#__PURE__*/function (_Templated) {
    _inherits(Search, _Templated);

    var _super = _createSuper(Search);

    function Search(container, options) {
      var _this;

      _classCallCheck(this, Search);

      _this = _super.call(this, container, options);

      _this.Elem("typeahead").storeFn = function (value) {
        return Requests.Typeahead(value);
      };

      _this.Elem("typeahead").On("Change", _this.OnTypeahead_Change.bind(_assertThisInitialized(_this)));

      return _this;
    }

    _createClass(Search, [{
      key: "OnTypeahead_Change",
      value: function OnTypeahead_Change(ev) {
        var _this2 = this;

        this.Emit("Busy");
        Requests.Placename(ev.item.id, ev.item.label).then(function (feature) {
          _this2.Emit("Idle");

          _this2.Emit("Change", {
            feature: feature
          });
        }, function (error) {
          _this2.Emit("Error", {
            error: error
          });
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div handle='root'>" + "&lt;div handle='typeahead' widget='Basic.Components.DynamicTypeahead'>&lt;/div>" + "&lt;/div>";
      }
    }]);

    return Search;
  }(Templated));

  Core.Templatable("App.Widgets.Waiting", /*#__PURE__*/function (_Templated) {
    _inherits(Waiting, _Templated);

    var _super = _createSuper(Waiting);

    function Waiting(container, options) {
      var _this;

      _classCallCheck(this, Waiting);

      _this = _super.call(this, container, options);

      _this.Hide();

      return _this;
    }

    _createClass(Waiting, [{
      key: "Show",
      value: function Show() {
        Dom.RemoveCss(this.container, "hidden");
      }
    }, {
      key: "Hide",
      value: function Hide() {
        Dom.AddCss(this.container, "hidden");
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;label handle='label'>nls(Waiting_Label)&lt;/label>" + "&lt;i class='fa fa-circle-o-notch fa-spin'>&lt;/i>";
      }
    }]);

    return Waiting;
  }(Templated));

  Core.Templatable("App.Widgets.Basemap", /*#__PURE__*/function (_Overlay) {
    _inherits(Basemap, _Overlay);

    var _super = _createSuper(Basemap);

    function Basemap(container, options) {
      _classCallCheck(this, Basemap);

      return _super.call(this, container, options);
    }

    _createClass(Basemap, [{
      key: "Map",
      set: function set(value) {
        this.map = value;
        new ESRI.widgets.BasemapGallery({
          view: this.map.view,
          container: this.Elem("body"),
          source: {
            portal: {
              url: "https://www.arcgis.com",
              useVectorBasemaps: true // Load vector tile basemaps

            }
          }
        }); // this.map.view.ui.add(basemap, "bottom-left");
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='overlay-header'>" + "&lt;h2 class='overlay-title' handle='title'>nls(Basemap_Title)&lt;/h2>" + "&lt;button class='overlay-close' handle='close' title='nls(Overlay_Close)'>×&lt;/button>" + "&lt;/div>" + "&lt;hr>" + "&lt;div class='overlay-body' handle='body'>" + "&lt;/div>";
      }
    }]);

    return Basemap;
  }(Overlay));

  Core.Templatable("App.Widgets.Bookmarks", /*#__PURE__*/function (_Overlay) {
    _inherits(Bookmarks, _Overlay);

    var _super = _createSuper(Bookmarks);

    function Bookmarks(container, options) {
      var _this;

      _classCallCheck(this, Bookmarks);

      _this = _super.call(this, container, options);
      _this.bookmarks = null;
      return _this;
    }

    _createClass(Bookmarks, [{
      key: "Map",
      set: function set(value) {
        this.map = value;
        this.bookmarks = new ESRI.widgets.Bookmarks({
          view: this.map.view,
          container: this.Elem("body"),
          editingEnabled: false
        });
      }
    }, {
      key: "Bookmarks",
      set: function set(value) {
        this.bookmarks.bookmarks = value;
        /*
        var bookmarks = value.sort((a,b) => {
        	if (a.name > b.name) return 1;
        	
        	if (a.name &lt; b.name) return -1;
        	
        	return 0;
        })
        
        this.bookmarks.bookmarks = bookmarks.map(b => {
        	return {
        		name : b.name,
        		extent : {
        			xmin : b.extent[0][0],
        			xmax : b.extent[1][0],
        			ymin : b.extent[0][1],
        			ymax : b.extent[1][1],
        		}
        	}
        }); 
        */
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='overlay-header'>" + "&lt;h2 class='overlay-title' handle='title'>nls(Bookmarks_Title)&lt;/h2>" + "&lt;button class='overlay-close' handle='close' title='nls(Overlay_Close)'>×&lt;/button>" + "&lt;/div>" + "&lt;hr>" + "&lt;div class='overlay-body' handle='body'>" + "&lt;/div>";
      }
    }]);

    return Bookmarks;
  }(Overlay));

  Core.Templatable("App.Widgets.Table", /*#__PURE__*/function (_Templated) {
    _inherits(Table, _Templated);

    var _super = _createSuper(Table);

    function Table(container) {
      var _this;

      _classCallCheck(this, Table);

      _this = _super.call(this, container);
      Dom.AddCss(_this.container, 'hidden');
      return _this;
    }

    _createClass(Table, [{
      key: "Title",
      set: function set(value) {
        this.Elem("title").innerHTML = value;
      }
    }, {
      key: "Headers",
      set: function set(value) {
        var _this2 = this;

        this.headers = value;
        Dom.Create("th", {}, this.Elem("header"));
        this.headers.forEach(function (h) {
          Dom.Create("th", {
            innerHTML: h.label
          }, _this2.Elem("header"));
        });
      }
    }, {
      key: "data",
      set: function set(value) {
        this.Populate(value);
      }
    }, {
      key: "Update",
      value: function Update(context) {
        this.context = context;
        Dom.Empty(this.Elem('body'));
        Dom.RemoveCss(this.container, 'hidden');
        this.UpdateTableVisibility();
        this.Title = this.context.IndicatorsLabel();
      } //Update the table content with the correct data of the DBU

    }, {
      key: "Populate",
      value: function Populate(graphics) {
        var _this3 = this;

        Dom.Empty(this.Elem('body'));
        graphics.forEach(function (g) {
          var name = g.attributes[_this3.headers[1].id];
          var tr = Dom.Create("tr", {
            className: "table-row"
          }, _this3.Elem("body"));

          _this3.CreateButton(tr, g, name);

          _this3.headers.forEach(function (f) {
            Dom.Create("td", {
              className: "table-cell",
              innerHTML: g.attributes[f.id]
            }, tr);
          });

          tr.title = Core.Nls("Table_Row_Title", [name]);
          tr.addEventListener("click", function (ev) {
            return _this3.Emit("RowClick", {
              feature: g
            });
          });
        });
        this.UpdateTableVisibility();
      }
    }, {
      key: "CreateButton",
      value: function CreateButton(tr, g, name) {
        var _this4 = this;

        var td = Dom.Create("td", {
          className: "table-cell"
        }, tr);
        var bt = Dom.Create("button", {
          className: "table-button",
          title: Core.Nls("Table_Thrash_Title", [name])
        }, td);
        Dom.Create("i", {
          className: "fa fa-trash"
        }, bt);
        bt.addEventListener("click", function (ev) {
          ev.stopPropagation();

          _this4.Emit("RowButtonClick", {
            graphic: g
          });
        });
      }
    }, {
      key: "UpdateTableVisibility",
      value: function UpdateTableVisibility() {
        var isVisible = this.Elem("body").children.length > 0;
        Dom.ToggleCss(this.Elem("message"), 'hidden', isVisible);
        Dom.ToggleCss(this.Elem("table"), 'hidden', !isVisible);
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='table-widget'>" + "&lt;h2 handle='title'>&lt;/h2>" + "&lt;div handle='message' class='table-message'>nls(Table_Message)&lt;/div>" + "&lt;div handle='table' class='table-container hidden'>" + "&lt;summary handle='description'>&lt;/summary>" + "&lt;table>" + "&lt;thead>" + "&lt;tr handle='header'>&lt;/tr>" + "&lt;/thead>" + "&lt;tbody handle='body'>&lt;/tbody>" + "&lt;/table>" + "&lt;/div>" + "&lt;/div>";
      }
    }]);

    return Table;
  }(Templated));

  var Application = /*#__PURE__*/function (_Templated) {
    _inherits(Application, _Templated);

    var _super = _createSuper(Application);

    function Application(node, config) {
      var _this;

      _classCallCheck(this, Application);

      _this = _super.call(this, node);
      _this.config = config; // Build context, map, menu, widgets and other UI components

      _this.context = new Context();
      _this.map = new Map(_this.Elem('map'));
      _this.menu = new Menu();
      _this.bMenu = new Menu();

      _this.menu.AddOverlay("selector", Core.Nls("Selector_Title"), _this.Elem("selector"));

      _this.menu.AddOverlay("chart", Core.Nls("Chart_Title"), _this.Elem("chart"));

      _this.menu.AddOverlay("styler", Core.Nls("Styler_Title"), _this.Elem("styler"));

      _this.menu.AddOverlay("legend", Core.Nls("Legend_Title"), _this.Elem("legend"));

      _this.menu.AddOverlay("bookmarks", Core.Nls("Bookmarks_Title"), _this.Elem("bookmarks"));

      _this.menu.AddButton("behaviour", Core.Nls("Behaviour_Title"));

      _this.bMenu.AddOverlay("basemap", Core.Nls("Basemap_Title"), _this.Elem("basemap")); // Move all widgets inside the map div, required for fullscreen


      _this.map.Place(_this.bMenu.Buttons, "bottom-left");

      _this.map.Place(_this.menu.Buttons, "top-left");

      _this.map.Place([_this.Elem("basemap").container], "bottom-left"); // Add chart here


      _this.map.Place(_this.Elems("selector", "chart", "styler", "legend", "bookmarks").map(function (e) {
        return e.container;
      }), "top-right");

      _this.map.Place([_this.Elem("waiting").container], "manual"); // Hookup events to UI


      _this.HandleEvents(_this.map);

      _this.HandleEvents(_this.context);

      _this.HandleEvents(_this.Node('chart'), _this.OnChart_Change.bind(_assertThisInitialized(_this)));

      _this.HandleEvents(_this.Node('selector'), _this.OnSelector_Change.bind(_assertThisInitialized(_this)));

      _this.HandleEvents(_this.Node('styler'), _this.OnStyler_Change.bind(_assertThisInitialized(_this)));

      _this.HandleEvents(_this.Node('search'), _this.OnSearch_Change.bind(_assertThisInitialized(_this)));

      _this.menu.Button("behaviour").addEventListener("click", _this.BehaviourButton_Click.bind(_assertThisInitialized(_this)));

      _this.Node("table").On("RowClick", _this.OnTable_RowClick.bind(_assertThisInitialized(_this)));

      _this.Node("table").On("RowButtonClick", _this.OnTable_RowButtonClick.bind(_assertThisInitialized(_this)));

      _this.Node('legend').On('Opacity', _this.OnLegend_Opacity.bind(_assertThisInitialized(_this)));

      _this.Node('legend').On('LayerVisibility', _this.OnLegend_LayerVisibility.bind(_assertThisInitialized(_this))); // FIX: Name of event handler is not consistent, first letter uppercase, name should reflect event


      _this.Node('legend').On('LabelVisibility', _this.onLegend_LabelName.bind(_assertThisInitialized(_this)));

      _this.map.AddMapImageLayer('main', _this.config.MapUrl, _this.config.MapOpacity);

      _this.Elem("table").Headers = _this.config.TableHeaders;
      _this.Elem('legend').Opacity = _this.config.MapOpacity;
      _this.Elem('basemap').Map = _this.map;
      _this.Elem('bookmarks').Map = _this.map;
      _this.Elem('bookmarks').Bookmarks = _this.config.Bookmarks; // this.config.LegendItems.forEach(i => {
      // 	this.map.AddFeatureLayer(i.id, i.url, i.labels, false);
      // 	this.Elem("legend").AddContextLayer(i.label, i, false);
      // })

      _this.context.Initialize(config.context).then(function (d) {
        _this.map.AddSubLayer('main', _this.context.sublayer); // FIX: Use the map component function to find the 'main' layer. We shouldn't
        // find a sublayer by it's index like this, what if there are more sublayers
        // in the future?


        _this.map.layers["main"].findSublayerById(7).labelsVisible = false;

        _this.Elem("selector").Update(_this.context);

        _this.Elem("styler").Update(_this.context);

        _this.Elem("legend").Update(_this.context);

        _this.Elem("table").Update(_this.context);

        _this.menu.SetOverlay(_this.menu.Item("legend"));

        _this.AddSelectBehavior(_this.map, _this.context, _this.config);

        _this.AddIdentifyBehavior(_this.map, _this.context, _this.config);

        _this.map.Behavior("identify").Activate();

        _this.behavior = "identify";
      }, function (error) {
        return _this.OnApplication_Error(error);
      });

      return _this;
    } // Behaviour object


    _createClass(Application, [{
      key: "AddSelectBehavior",
      value: function AddSelectBehavior(map, context, config) {
        var options = {
          layer: context.sublayer,
          field: "GeographyReferenceId",
          symbol: config.symbol("selection")
        };
        var behavior = this.map.AddBehavior("selection", new RectangleSelectBehavior(map, options)); // Where it happens
        // MAPSELECTDAW

        this.HandleEvents(behavior, this.OnMap_SelectDraw.bind(this));
      }
    }, {
      key: "AddIdentifyBehavior",
      value: function AddIdentifyBehavior(map, context, config) {
        var options = {
          layer: context.sublayer,
          symbol: config.symbol("identify")
        };
        var behavior = this.map.AddBehavior("identify", new PointIdentifyBehavior(map, options));
        this.HandleEvents(behavior);
      } // Add event handler

    }, {
      key: "HandleEvents",
      value: function HandleEvents(node, changeHandler) {
        if (changeHandler) node.On('Change', changeHandler);
        node.On('Busy', this.OnWidget_Busy.bind(this));
        node.On('Idle', this.OnWidget_Idle.bind(this));
        node.On('Error', this.OnApplication_Error.bind(this));
      }
    }, {
      key: "BehaviourButton_Click",
      value: function BehaviourButton_Click(ev) {
        this.map.Behavior(this.behavior).Deactivate();
        this.behavior = this.behavior == "identify" ? "selection" : "identify";
        this.map.Behavior(this.behavior).Activate();
      }
    }, {
      key: "OnSelector_Change",
      value: function OnSelector_Change(ev) {
        this.map.EmptyLayer('main');
        this.map.AddSubLayer('main', this.context.sublayer);
        this.map.Behavior("selection").Reset({
          layer: this.context.sublayer
        }); // this.map.Behavior("identify").Reset({ layer:this.context.sublayer });

        this.Elem("styler").Update(this.context);
        this.Elem("legend").Update(this.context);
        this.Elem("table").Update(this.context);
      }
    }, {
      key: "OnChart_Change",
      value: function OnChart_Change(ev) {
        this.map.EmptyLayer('main');
        this.map.AddSubLayer('main', this.context.sublayer);
        this.map.Behavior("selection").Reset({
          layer: this.context.sublayer
        }); // this.map.Behavior("identify").Reset({ layer:this.context.sublayer });

        this.Elem("styler").Update(this.context);
        this.Elem("legend").Update(this.context);
        this.Elem("table").Update(this.context);
      }
    }, {
      key: "OnStyler_Change",
      value: function OnStyler_Change(ev) {
        this.context.sublayer.renderer = ev.renderer;
        this.Elem("legend").Update(this.context);
      }
    }, {
      key: "OnLegend_Opacity",
      value: function OnLegend_Opacity(ev) {
        this.map.Layer('main').opacity = ev.opacity;
      }
    }, {
      key: "OnLegend_LayerVisibility",
      value: function OnLegend_LayerVisibility(ev) {
        var l = this.map.Layer(ev.data.id);
        if (!l) return;
        l.visible = ev.checked;
      } // FIX: Yanick reported that labels automatically switch back on when the user switches geography, something to look into...

    }, {
      key: "onLegend_LabelName",
      value: function onLegend_LabelName(ev) {
        // FIX: Same as above
        this.map.layers["main"].findSublayerById(7).labelsVisible = ev.checked;
      }
    }, {
      key: "OnSearch_Change",
      value: function OnSearch_Change(ev) {
        this.map.GoTo(ev.feature.geometry);
      }
    }, {
      key: "OnTable_RowClick",
      value: function OnTable_RowClick(ev) {
        this.map.GoTo(ev.feature.geometry);
      } // Selection changes, in ev.selection 

    }, {
      key: "OnMap_SelectDraw",
      value: function OnMap_SelectDraw(ev) {
        this.Elem("table").data = ev.selection;
        this.Elem("chart").data = ev.selection.items;
      } // More changes

    }, {
      key: "OnTable_RowButtonClick",
      value: function OnTable_RowButtonClick(ev) {
        this.map.Behavior("selection").Layer.remove(ev.graphic);
        this.Elem("table").data = this.map.Behavior("selection").Graphics;
        this.Elem("chart").data = this.map.Behavior("selection").Graphics.items;
      }
    }, {
      key: "OnWidget_Busy",
      value: function OnWidget_Busy(ev) {
        this.Elem("waiting").Show();
      }
    }, {
      key: "OnWidget_Idle",
      value: function OnWidget_Idle(ev) {
        this.Elem("waiting").Hide();
      }
    }, {
      key: "OnApplication_Error",
      value: function OnApplication_Error(error) {
        alert(error.message);
        console.error(error);
      }
    }, {
      key: "Template",
      value: function Template() {
        return "&lt;div class='top-container'>" + "&lt;img class='button-icon large-icon search' src='./assets/search-24.png' alt='nls(Search_Icon_Alt)' />" + "&lt;div handle='search' widget='App.Widgets.Search'>&lt;/div>" + "&lt;/div>" + "&lt;div class='map-container'>" + "&lt;div handle='map'>&lt;/div>" + "&lt;div handle='selector' class='selector' widget='App.Widgets.Selector'>&lt;/div>" + "&lt;div handle='chart' class='chart' widget='App.Widgets.WChart'>&lt;/div>" + "&lt;div handle='styler' class='styler' widget='App.Widgets.Styler'>&lt;/div>" + "&lt;div handle='legend' class='legend' widget='App.Widgets.Legend'>&lt;/div>" + "&lt;div handle='waiting' class='waiting' widget='App.Widgets.Waiting'>&lt;/div>" + "&lt;div handle='basemap' class='basemap' widget='App.Widgets.Basemap'>&lt;/div>" + "&lt;div handle='bookmarks' class='bookmarks' widget='App.Widgets.Bookmarks'>&lt;/div>" + "&lt;/div>" + "&lt;div handle='table' class='table' widget='App.Widgets.Table'>&lt;/div>";
      }
    }]);

    return Application;
  }(Templated);

  window.ESRI = null;
  if (wb &amp;&amp; wb.isReady) DocumentReady();else $(document).on("wb-ready.wb", function (ev) {
    return DocumentReady();
  });

  function DocumentReady() {
    var p1 = Net.JSON("./nls.json");
    var p2 = Net.JSON("./application.json");
    var p3 = LoadEsri();
    Promise.all([p1, p2, p3]).then(Start, Fail);
  }

  function Start(responses) {
    Core.locale = document.documentElement.lang || "en";
    Core.nls = responses[0];
    var div = Dom.Node(document.body, "#app-container");
    new Application(div, new Configuration(responses[1]));
  }

  function Fail(response) {
    alert("Unable to load application.");
    throw new Error("Unable to load application.");
  }

  function LoadEsri() {
    var d = Core.Defer();
    var esriJs = document.createElement('script');
    esriJs.addEventListener("load", function (ev) {
      require(["esri/renderers/support/jsonUtils", "esri/renderers/Renderer", "esri/request", "esri/layers/MapImageLayer", "esri/layers/FeatureLayer", "esri/layers/GraphicsLayer", "esri/layers/support/Sublayer", "esri/core/urlUtils", "esri/core/watchUtils", "esri/Map", "esri/Graphic", "esri/views/MapView", "esri/views/draw/Draw", "esri/widgets/BasemapGallery", "esri/widgets/Bookmarks", "esri/widgets/Fullscreen"], function (jsonUtils, Renderer, request, MapImageLayer, FeatureLayer, GraphicsLayer, Sublayer, urlUtils, watchUtils, Map, Graphic, MapView, Draw, BasemapGallery, Bookmarks, Fullscreen) {
        window.ESRI = {
          core: {
            urlUtils: urlUtils,
            watchUtils: watchUtils
          },
          request: request,
          Map: Map,
          Graphic: Graphic,
          views: {
            MapView: MapView,
            draw: {
              Draw: Draw
            }
          },
          renderers: {
            Renderer: Renderer,
            support: {
              jsonUtils: jsonUtils
            }
          },
          layers: {
            MapImageLayer: MapImageLayer,
            FeatureLayer: FeatureLayer,
            GraphicsLayer: GraphicsLayer,
            support: {
              Sublayer: Sublayer
            }
          },
          widgets: {
            Fullscreen: Fullscreen,
            BasemapGallery: BasemapGallery,
            Bookmarks: Bookmarks
          }
        }; // TODO: This won't hold once deployed. Need to find a better way of setting the proxy.

        var ext = navigator.appVersion.indexOf("Win") == -1 ? "jsp" : "ashx";
        urlUtils.addProxyRule({
          urlPrefix: "www97.statcan.gc.ca",
          proxyUrl: "".concat(location.origin, "/geo-explorer-proxy/proxy.").concat(ext)
        });
        d.Resolve();
      });
    });
    esriJs.setAttribute('src', './reference/dojo.js');
    document.head.appendChild(esriJs);
    return d.promise;
  }

}());
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-behaviors_behavior.html">behaviors/behavior</a></li><li><a href="module-behaviors_point-identify.html">behaviors/point-identify</a></li><li><a href="module-behaviors_rectangle-select.html">behaviors/rectangle-select</a></li><li><a href="module-charts_axes.html">charts/axes</a></li><li><a href="module-charts_barChart.html">charts/barChart</a></li><li><a href="module-charts_chart.html">charts/chart</a></li><li><a href="module-charts_linechart.html">charts/linechart</a></li><li><a href="module-charts_pieChart.html">charts/pieChart</a></li><li><a href="module-charts_scatterPlot.html">charts/scatterPlot</a></li><li><a href="module-components_configuration.html">components/configuration</a></li><li><a href="module-components_context.html">components/context</a></li><li><a href="module-components_evented.html">components/evented</a></li><li><a href="module-components_map.html">components/map</a></li><li><a href="module-components_nls.html">components/nls</a></li><li><a href="module-components_node.html">components/node</a></li><li><a href="module-components_templated.html">components/templated</a></li><li><a href="module-components_templated-table.html">components/templated-table</a></li><li><a href="module-tools_core.html">tools/core</a></li><li><a href="module-tools_dom.html">tools/dom</a></li><li><a href="module-tools_net.html">tools/net</a></li><li><a href="module-tools_requests.html">tools/requests</a></li><li><a href="module-ui_picker.html">ui/picker</a></li><li><a href="module-ui_popup.html">ui/popup</a></li><li><a href="module-ui_select.html">ui/select</a></li><li><a href="module-ui_tooltip.html">ui/tooltip</a></li><li><a href="module-ui_typeahead_dynamic.html">ui/typeahead/dynamic</a></li><li><a href="module-ui_typeahead_static.html">ui/typeahead/static</a></li><li><a href="module-ui_typeahead_typeahead.html">ui/typeahead/typeahead</a></li><li><a href="module-widgets_basemap.html">widgets/basemap</a></li><li><a href="module-widgets_bookmarks.html">widgets/bookmarks</a></li><li><a href="module-widgets_legend_legend.html">widgets/legend/legend</a></li><li><a href="module-widgets_legend_legend-break.html">widgets/legend/legend-break</a></li><li><a href="module-widgets_menu.html">widgets/menu</a></li><li><a href="module-widgets_overlay.html">widgets/overlay</a></li><li><a href="module-widgets_search.html">widgets/search</a></li><li><a href="module-widgets_selector.html">widgets/selector</a></li><li><a href="module-widgets_styler_styler.html">widgets/styler/styler</a></li><li><a href="module-widgets_styler_styler-break.html">widgets/styler/styler-break</a></li><li><a href="module-widgets_table.html">widgets/table</a></li><li><a href="module-widgets_waiting.html">widgets/waiting</a></li><li><a href="module-widgets_wChart.html">widgets/wChart</a></li></ul><h3>Classes</h3><ul><li><a href="module-ui_tooltip.html">ui/tooltip</a></li><li><a href="module-widgets_menu.html">widgets/menu</a></li><li><a href="module-widgets_overlay.html">widgets/overlay</a></li></ul><h3>Global</h3><ul><li><a href="global.html#set">set</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Apr 28 2021 14:44:33 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
